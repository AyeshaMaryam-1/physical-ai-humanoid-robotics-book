"use strict";(globalThis.webpackChunkbook_temp=globalThis.webpackChunkbook_temp||[]).push([[831],{7185:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module_2/2_4_digital_twin","title":"Complete Digital Twin Pipeline","description":"Purpose","source":"@site/docs/02_module_2/2_4_digital_twin.mdx","sourceDirName":"02_module_2","slug":"/module_2/2_4_digital_twin","permalink":"/physical-ai-humanoid-robotics-book/docs/module_2/2_4_digital_twin","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02_module_2/2_4_digital_twin.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Complete Digital Twin Pipeline"},"sidebar":"tutorialSidebar","previous":{"title":"High-Fidelity Visualization (Unity)","permalink":"/physical-ai-humanoid-robotics-book/docs/module_2/2_3_unity_viz"},"next":{"title":"NVIDIA Isaac Sim Essentials","permalink":"/physical-ai-humanoid-robotics-book/docs/module_3/3_1_isaac_sim_essentials"}}');var o=i(4848),r=i(8453);const s={sidebar_position:4,title:"Complete Digital Twin Pipeline"},a="Complete Digital Twin Pipeline",l={},c=[{value:"Purpose",id:"purpose",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Outputs",id:"outputs",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Chapter Outline",id:"chapter-outline",level:2},{value:"1. Unified Launch System",id:"1-unified-launch-system",level:3},{value:"2. State Synchronization",id:"2-state-synchronization",level:3},{value:"3. Control Pipeline",id:"3-control-pipeline",level:3},{value:"4. Performance Optimization",id:"4-performance-optimization",level:3},{value:"Hands-On Lab",id:"hands-on-lab",level:2},{value:"Creating the Complete Digital Twin Pipeline",id:"creating-the-complete-digital-twin-pipeline",level:3},{value:"Safety Notes",id:"safety-notes",level:2},{value:"Evaluation Criteria",id:"evaluation-criteria",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"complete-digital-twin-pipeline",children:"Complete Digital Twin Pipeline"})}),"\n",(0,o.jsx)(e.h2,{id:"purpose",children:"Purpose"}),"\n",(0,o.jsx)(e.p,{children:"This chapter integrates all components of our digital twin system, connecting URDF robot description, ROS 2 control, Gazebo simulation, and Unity visualization into a unified pipeline. We'll create a comprehensive launch system that synchronizes all components, enabling real-time control and visualization across multiple platforms."}),"\n",(0,o.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Create a unified launch system for Gazebo, ROS 2, and Unity"}),"\n",(0,o.jsx)(e.li,{children:"Synchronize robot states across simulation and visualization platforms"}),"\n",(0,o.jsx)(e.li,{children:"Implement real-time control and feedback loops in the digital twin"}),"\n",(0,o.jsx)(e.li,{children:"Debug and monitor the complete digital twin pipeline"}),"\n",(0,o.jsx)(e.li,{children:"Optimize performance across the integrated system"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Completed Module 1 (ROS 2 fundamentals and humanoid URDF)"}),"\n",(0,o.jsx)(e.li,{children:"Completed Module 2.1-2.3 (Gazebo simulation, sensors, and Unity visualization)"}),"\n",(0,o.jsx)(e.li,{children:"Understanding of ros2_control and sensor integration"}),"\n",(0,o.jsx)(e.li,{children:"Basic knowledge of Unity-ROS communication"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"inputs",children:"Inputs"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Completed humanoid robot URDF with sensors and ros2_control"}),"\n",(0,o.jsx)(e.li,{children:"Working Gazebo simulation with sensor data"}),"\n",(0,o.jsx)(e.li,{children:"Unity project with ROS integration"}),"\n",(0,o.jsx)(e.li,{children:"Understanding of launch file creation in ROS 2"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"outputs",children:"Outputs"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Unified launch file for complete digital twin system"}),"\n",(0,o.jsx)(e.li,{children:"Synchronized control and visualization pipeline"}),"\n",(0,o.jsx)(e.li,{children:"Performance optimization strategies"}),"\n",(0,o.jsx)(e.li,{children:"Monitoring and debugging tools for the digital twin"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Digital Twin Architecture"}),": Integration of multiple simulation and visualization platforms"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Unified Launch System"}),": Single launch file to start all components"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"State Synchronization"}),": Keeping robot states consistent across platforms"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Performance Optimization"}),": Ensuring smooth operation of integrated system"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Real-time Communication"}),": Maintaining low-latency communication between components"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Monitoring and Debugging"}),": Tools to observe and troubleshoot the digital twin"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"System Integration"}),": Connecting all components into a cohesive pipeline"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"chapter-outline",children:"Chapter Outline"}),"\n",(0,o.jsx)(e.p,{children:"This chapter creates a complete digital twin pipeline:"}),"\n",(0,o.jsx)(e.h3,{id:"1-unified-launch-system",children:"1. Unified Launch System"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Creating a comprehensive launch file for all components"}),"\n",(0,o.jsx)(e.li,{children:"Managing dependencies between Gazebo, ROS 2, and Unity"}),"\n",(0,o.jsx)(e.li,{children:"Configuring communication protocols and parameters"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"2-state-synchronization",children:"2. State Synchronization"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Ensuring consistent robot states across platforms"}),"\n",(0,o.jsx)(e.li,{children:"Handling joint state propagation and timing"}),"\n",(0,o.jsx)(e.li,{children:"Managing sensor data distribution"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"3-control-pipeline",children:"3. Control Pipeline"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Implementing unified control interfaces"}),"\n",(0,o.jsx)(e.li,{children:"Managing feedback loops and safety limits"}),"\n",(0,o.jsx)(e.li,{children:"Coordinating command distribution"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"4-performance-optimization",children:"4. Performance Optimization"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Optimizing communication bandwidth"}),"\n",(0,o.jsx)(e.li,{children:"Managing update rates and timing"}),"\n",(0,o.jsx)(e.li,{children:"Ensuring smooth visualization performance"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"hands-on-lab",children:"Hands-On Lab"}),"\n",(0,o.jsx)(e.h3,{id:"creating-the-complete-digital-twin-pipeline",children:"Creating the Complete Digital Twin Pipeline"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Unified Launch File:"}),"\nCreate a comprehensive launch file that starts all components of our digital twin: ",(0,o.jsx)(e.code,{children:"robotics_ws/src/humanoid_description/launch/full_digital_twin.launch.py"})]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch.event_handlers import OnProcessExit\nfrom launch.actions import ExecuteProcess\nimport os\n\ndef generate_launch_description():\n    # Get the package share directory\n    pkg_share = get_package_share_directory('humanoid_description')\n    default_model_path = os.path.join(pkg_share, 'urdf/simple_humanoid.urdf')\n    default_world_path = os.path.join(pkg_share, 'worlds/empty_world.world')\n\n    # Declare launch arguments\n    model_arg = DeclareLaunchArgument(\n        name='model',\n        default_value=default_model_path,\n        description='Absolute path to robot urdf file'\n    )\n\n    world_arg = DeclareLaunchArgument(\n        name='world',\n        default_value=default_world_path,\n        description='Absolute path to world file'\n    )\n\n    # Start Gazebo server and client\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': LaunchConfiguration('world'),\n            'verbose': 'false',\n        }.items()\n    )\n\n    # Robot State Publisher node\n    robot_state_publisher_node = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        parameters=[{\n            'robot_description': open(default_model_path).read()\n        }]\n    )\n\n    # Spawn the robot in Gazebo\n    spawn_entity_node = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-file', LaunchConfiguration('model'),\n            '-entity', 'simple_humanoid',\n            '-x', '0.0',\n            '-y', '0.0',\n            '-z', '1.0'\n        ],\n        output='screen'\n    )\n\n    # ros2_control using FakeSystem as hardware interface\n    ros2_controllers_path = os.path.join(\n        get_package_share_directory('humanoid_description'),\n        'config',\n        'simple_humanoid_controllers.yaml'\n    )\n\n    robot_controllers = Node(\n        package='controller_manager',\n        executable='ros2_control_node',\n        parameters=[robot_controllers_path],\n        output='both',\n    )\n\n    # Joint State Broadcaster\n    joint_state_broadcaster_spawner = Node(\n        package='controller_manager',\n        executable='spawner',\n        arguments=['joint_state_broadcaster', '--controller-manager', '/controller_manager'],\n    )\n\n    # Robot specific controllers\n    robot_controller_spawner = Node(\n        package='controller_manager',\n        executable='spawner',\n        arguments=['forward_position_controller', '--controller-manager', '/controller_manager'],\n    )\n\n    # Sensor Processor node\n    sensor_processor_node = Node(\n        package='ai_control_agent',\n        executable='sensor_processor',\n        name='sensor_processor',\n        output='screen'\n    )\n\n    # RViz2 node\n    rviz_node = Node(\n        package='rviz2',\n        executable='rviz2',\n        name='rviz2',\n        output='screen'\n    )\n\n    # Unity ROS TCP Endpoint (for Unity communication)\n    unity_ros_tcp_endpoint = Node(\n        package='ros_tcp_endpoint',\n        executable='default_server_endpoint',\n        name='unity_ros_tcp_endpoint',\n        parameters=[\n            {'tcp_port': 10000},\n            {'namespace': ''},\n            {'buffer_size': 65536},\n            {'RosUnityTcpAddress': '0.0.0.0'}  # Listen on all interfaces\n        ],\n        output='screen'\n    )\n\n    # Event handler to start controllers after ros2_control_node\n    delay_rviz_after_spawner = RegisterEventHandler(\n        event_handler=OnProcessExit(\n            target_action=joint_state_broadcaster_spawner,\n            on_exit=[rviz_node],\n        )\n    )\n\n    delay_unity_endpoint_after_spawner = RegisterEventHandler(\n        event_handler=OnProcessExit(\n            target_action=joint_state_broadcaster_spawner,\n            on_exit=[unity_ros_tcp_endpoint],\n        )\n    )\n\n    return LaunchDescription([\n        model_arg,\n        world_arg,\n        gazebo,\n        robot_state_publisher_node,\n        spawn_entity_node,\n        robot_controllers,\n        joint_state_broadcaster_spawner,\n        robot_controller_spawner,\n        sensor_processor_node,\n        delay_rviz_after_spawner,\n        delay_unity_endpoint_after_spawner\n    ])\n"})}),"\n",(0,o.jsxs)(e.ol,{start:"2",children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Controller Configuration:"}),"\nCreate the controller configuration file: ",(0,o.jsx)(e.code,{children:"robotics_ws/src/humanoid_description/config/simple_humanoid_controllers.yaml"})]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"controller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    forward_position_controller:\n      type: position_controllers/JointGroupPositionController\n\nforward_position_controller:\n  ros__parameters:\n    joints:\n      - left_hip_joint\n      - left_knee_joint\n      - left_shoulder_joint\n      - left_elbow_joint\n      - right_hip_joint\n      - right_knee_joint\n      - right_shoulder_joint\n      - right_elbow_joint\n\n# Add more controllers as needed for your specific robot\n"})}),"\n",(0,o.jsxs)(e.ol,{start:"3",children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Digital Twin Test Script:"}),"\nCreate a test script to verify the complete digital twin pipeline: ",(0,o.jsx)(e.code,{children:"robotics_ws/src/ai_control_agent/ai_control_agent/digital_twin_test.py"})]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n\n"""\nDigital Twin Test Script\n\nThis script tests the complete digital twin pipeline by:\n1. Publishing joint commands to control the robot\n2. Monitoring sensor data from the simulated robot\n3. Verifying synchronization between Gazebo and Unity\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\nfrom sensor_msgs.msg import JointState, LaserScan, Image, Imu\nfrom builtin_interfaces.msg import Duration\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom control_msgs.msg import JointTrajectoryControllerState\nimport time\nimport math\n\n\nclass DigitalTwinTester(Node):\n    def __init__(self):\n        super().__init__(\'digital_twin_tester\')\n\n        # Joint command publisher\n        self.joint_cmd_publisher = self.create_publisher(\n            JointTrajectory,\n            \'/forward_position_controller/joint_trajectory\',\n            10\n        )\n\n        # Sensor data subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10\n        )\n\n        self.lidar_sub = self.create_subscription(\n            LaserScan,\n            \'/lidar/scan\',\n            self.lidar_callback,\n            10\n        )\n\n        self.camera_sub = self.create_subscription(\n            Image,\n            \'/camera/image_raw\',\n            self.camera_callback,\n            10\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            \'/imu/data\',\n            self.imu_callback,\n            10\n        )\n\n        # Timer for sending commands\n        self.timer = self.create_timer(1.0, self.send_test_command)\n\n        self.joint_names = [\n            \'left_hip_joint\', \'left_knee_joint\', \'left_shoulder_joint\', \'left_elbow_joint\',\n            \'right_hip_joint\', \'right_knee_joint\', \'right_shoulder_joint\', \'right_elbow_joint\'\n        ]\n\n        self.get_logger().info("Digital Twin Tester initialized")\n\n    def send_test_command(self):\n        """Send a test joint trajectory command"""\n        msg = JointTrajectory()\n        msg.joint_names = self.joint_names\n\n        point = JointTrajectoryPoint()\n\n        # Create a simple oscillating motion\n        t = self.get_clock().now().nanoseconds / 1e9\n        amplitude = 0.5\n        frequency = 0.5\n\n        positions = []\n        for i, joint_name in enumerate(self.joint_names):\n            pos = amplitude * math.sin(2 * math.pi * frequency * t + i * math.pi / 4)\n            positions.append(pos)\n\n        point.positions = positions\n        point.time_from_start = Duration(sec=1, nanosec=0)\n\n        msg.points = [point]\n\n        self.joint_cmd_publisher.publish(msg)\n        self.get_logger().info(f"Sent joint command: {positions}")\n\n    def joint_state_callback(self, msg):\n        """Handle joint state updates"""\n        self.get_logger().debug(f"Received joint states: {len(msg.name)} joints")\n\n    def lidar_callback(self, msg):\n        """Handle LiDAR data"""\n        self.get_logger().debug(f"Received LiDAR data: {len(msg.ranges)} ranges")\n\n    def camera_callback(self, msg):\n        """Handle camera data"""\n        self.get_logger().debug(f"Received camera data: {msg.width}x{msg.height}")\n\n    def imu_callback(self, msg):\n        """Handle IMU data"""\n        self.get_logger().debug(f"Received IMU data: linear={msg.linear_acceleration}, angular={msg.angular_velocity}")\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    tester = DigitalTwinTester()\n\n    try:\n        rclpy.spin(tester)\n    except KeyboardInterrupt:\n        tester.get_logger().info("Shutting down Digital Twin Tester")\n    finally:\n        tester.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsxs)(e.ol,{start:"4",children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Launch and Test the Complete Digital Twin:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Launch the complete digital twin system:"}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"cd robotics_ws\nsource install/setup.bash\nros2 launch humanoid_description full_digital_twin.launch.py\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"In a separate terminal, start the Unity application with ROS integration"}),"\n",(0,o.jsx)(e.li,{children:"In another terminal, run the test script:"}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"ros2 run ai_control_agent digital_twin_test\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Verification Steps:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Verify that joint commands sent from ROS 2 affect both the Gazebo simulation and Unity visualization"}),"\n",(0,o.jsx)(e.li,{children:"Check that sensor data is being published and received correctly"}),"\n",(0,o.jsx)(e.li,{children:"Confirm that Unity is receiving joint states and updating the visualization in real-time"}),"\n",(0,o.jsx)(e.li,{children:"Monitor the synchronization between platforms"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Performance Monitoring:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Use ROS 2 tools to monitor communication performance:"}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Monitor topics\nros2 topic hz /joint_states\nros2 topic hz /forward_position_controller/joint_trajectory\n\n# Check system performance\nros2 run plotjuggler plotjuggler\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Troubleshooting:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"If Unity doesn't connect to ROS, verify the rosbridge server is running:"}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"ros2 launch rosbridge_server rosbridge_websocket_launch.xml\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Check network connectivity between ROS 2 and Unity"}),"\n",(0,o.jsx)(e.li,{children:"Verify that all required packages are installed and built"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"safety-notes",children:"Safety Notes"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Ensure proper error handling in the launch system for component failures"}),"\n",(0,o.jsx)(e.li,{children:"Implement safety limits for joint positions and velocities across all platforms"}),"\n",(0,o.jsx)(e.li,{children:"Monitor system performance to prevent instability in real-time operation"}),"\n",(0,o.jsx)(e.li,{children:"Include emergency stop capabilities across the entire digital twin system"}),"\n",(0,o.jsx)(e.li,{children:"Validate that safety protocols are consistent across simulation and visualization"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"evaluation-criteria",children:"Evaluation Criteria"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Does the unified launch file start all components correctly?"}),"\n",(0,o.jsx)(e.li,{children:"Are robot states synchronized across Gazebo and Unity?"}),"\n",(0,o.jsx)(e.li,{children:"Can commands be sent to control the robot in both simulation and visualization?"}),"\n",(0,o.jsx)(e.li,{children:"Are sensor data streams properly distributed to all subscribers?"}),"\n",(0,o.jsx)(e.li,{children:"Does the system maintain stable performance during operation?"}),"\n",(0,o.jsx)(e.li,{children:"Can the digital twin pipeline be reliably launched and shut down?"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>a});var t=i(6540);const o={},r=t.createContext(o);function s(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);