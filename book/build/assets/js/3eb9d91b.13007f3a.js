"use strict";(globalThis.webpackChunkbook_temp=globalThis.webpackChunkbook_temp||[]).push([[868],{3520:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module_2/2_1_gazebo_fundamentals","title":"Simulation Fundamentals in Gazebo","description":"Purpose","source":"@site/docs/02_module_2/2_1_gazebo_fundamentals.mdx","sourceDirName":"02_module_2","slug":"/module_2/2_1_gazebo_fundamentals","permalink":"/physical-ai-humanoid-robotics-book/docs/module_2/2_1_gazebo_fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02_module_2/2_1_gazebo_fundamentals.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Simulation Fundamentals in Gazebo"},"sidebar":"tutorialSidebar","previous":{"title":"Connecting AI Agents to ROS Controllers","permalink":"/physical-ai-humanoid-robotics-book/docs/module_1/1_4_ai_controllers"},"next":{"title":"Sensors in Simulation","permalink":"/physical-ai-humanoid-robotics-book/docs/module_2/2_2_sim_sensors"}}');var t=o(4848),r=o(8453);const a={sidebar_position:1,title:"Simulation Fundamentals in Gazebo"},s="Simulation Fundamentals in Gazebo",l={},c=[{value:"Purpose",id:"purpose",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Outputs",id:"outputs",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Chapter Outline",id:"chapter-outline",level:2},{value:"1. Gazebo Basics",id:"1-gazebo-basics",level:3},{value:"2. Robot Integration",id:"2-robot-integration",level:3},{value:"3. ros2_control Integration",id:"3-ros2_control-integration",level:3},{value:"4. Simulation Control",id:"4-simulation-control",level:3},{value:"Hands-On Lab",id:"hands-on-lab",level:2},{value:"Setting up Gazebo Simulation for Humanoid Robot",id:"setting-up-gazebo-simulation-for-humanoid-robot",level:3},{value:"Safety Notes",id:"safety-notes",level:2},{value:"Evaluation Criteria",id:"evaluation-criteria",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"simulation-fundamentals-in-gazebo",children:"Simulation Fundamentals in Gazebo"})}),"\n",(0,t.jsx)(e.h2,{id:"purpose",children:"Purpose"}),"\n",(0,t.jsx)(e.p,{children:"This chapter introduces Gazebo simulation fundamentals and demonstrates how to integrate our humanoid robot with Gazebo physics engine. We'll cover the basics of creating simulation environments, spawning robots, and controlling them through ROS 2 interfaces."}),"\n",(0,t.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(e.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Set up Gazebo simulation with ROS 2 integration"}),"\n",(0,t.jsx)(e.li,{children:"Spawn your humanoid robot in Gazebo environment"}),"\n",(0,t.jsx)(e.li,{children:"Control robot joints using ROS 2 topics and services"}),"\n",(0,t.jsx)(e.li,{children:"Configure physics properties and simulation parameters"}),"\n",(0,t.jsx)(e.li,{children:"Integrate Gazebo with ros2_control for realistic robot control"}),"\n",(0,t.jsx)(e.li,{children:"Debug and troubleshoot simulation issues"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Completed Module 1 (ROS 2 fundamentals and humanoid URDF)"}),"\n",(0,t.jsx)(e.li,{children:"Understanding of ROS 2 concepts and launch files"}),"\n",(0,t.jsx)(e.li,{children:"Basic knowledge of physics simulation concepts"}),"\n",(0,t.jsx)(e.li,{children:"Working ROS 2 Humble installation with Gazebo Garden/Harmonic"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"inputs",children:"Inputs"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Working humanoid URDF model from Module 1"}),"\n",(0,t.jsx)(e.li,{children:"ROS 2 Humble with Gazebo integration"}),"\n",(0,t.jsx)(e.li,{children:"Basic understanding of robot kinematics"}),"\n",(0,t.jsx)(e.li,{children:"Completed robot control packages from Module 1"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"outputs",children:"Outputs"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Gazebo simulation environment with humanoid robot"}),"\n",(0,t.jsx)(e.li,{children:"Working ros2_control integration in simulation"}),"\n",(0,t.jsx)(e.li,{children:"Launch files for simulation with robot control"}),"\n",(0,t.jsx)(e.li,{children:"Understanding of simulation-specific robot configurations"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gazebo Physics Engine"}),": Realistic physics simulation with collision detection, dynamics, and contacts"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gazebo ROS2 Control"}),": Integration layer between ROS 2 controllers and Gazebo physics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Model Spawning"}),": Process of loading robot models into the simulation environment"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Simulation Time"}),": Real-time vs. simulation time management and synchronization"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor Simulation"}),": Simulated sensors that mirror real-world counterparts"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"World Files"}),": Gazebo world definition files with environments, objects, and physics properties"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Plugin System"}),": Extensibility mechanism for custom simulation behaviors"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"chapter-outline",children:"Chapter Outline"}),"\n",(0,t.jsx)(e.p,{children:"This chapter builds from basic Gazebo concepts to full integration:"}),"\n",(0,t.jsx)(e.h3,{id:"1-gazebo-basics",children:"1. Gazebo Basics"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Installing and configuring Gazebo with ROS 2"}),"\n",(0,t.jsx)(e.li,{children:"Understanding Gazebo GUI and interfaces"}),"\n",(0,t.jsx)(e.li,{children:"Basic world creation and environment setup"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"2-robot-integration",children:"2. Robot Integration"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Adapting URDF for Gazebo simulation"}),"\n",(0,t.jsx)(e.li,{children:"Adding Gazebo-specific plugins and configurations"}),"\n",(0,t.jsx)(e.li,{children:"Setting up collision and visual properties"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"3-ros2_control-integration",children:"3. ros2_control Integration"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Configuring ros2_control for Gazebo"}),"\n",(0,t.jsx)(e.li,{children:"Joint trajectory controllers in simulation"}),"\n",(0,t.jsx)(e.li,{children:"Sensor integration and feedback"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"4-simulation-control",children:"4. Simulation Control"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Launching and controlling simulation"}),"\n",(0,t.jsx)(e.li,{children:"Real-time vs. simulation time management"}),"\n",(0,t.jsx)(e.li,{children:"Debugging and visualization tools"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"hands-on-lab",children:"Hands-On Lab"}),"\n",(0,t.jsx)(e.h3,{id:"setting-up-gazebo-simulation-for-humanoid-robot",children:"Setting up Gazebo Simulation for Humanoid Robot"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Create the worlds directory in the humanoid_description package:"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"mkdir -p ~/robotics_ws/src/humanoid_description/worlds\n"})}),"\n",(0,t.jsxs)(e.ol,{start:"2",children:["\n",(0,t.jsxs)(e.li,{children:["Create an empty world file at ",(0,t.jsx)(e.code,{children:"humanoid_description/worlds/empty_world.world"}),":"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="empty_world">\n    \x3c!-- Include the sun --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Add a ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Physics engine configuration --\x3e\n    <physics name="1ms" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000.0</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- GUI configuration --\x3e\n    <gui fullscreen="0">\n      <camera name="user_camera">\n        <pose>-5.0 0.0 3.0 0.0 0.4 0.0</pose>\n        <view_controller>orbit</view_controller>\n        <projection_type>perspective</projection_type>\n      </camera>\n    </gui>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsxs)(e.ol,{start:"3",children:["\n",(0,t.jsxs)(e.li,{children:["Update the launch file to include Gazebo integration in ",(0,t.jsx)(e.code,{children:"humanoid_description/launch/display_simple_humanoid.launch.py"}),":"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch.event_handlers import OnProcessExit\nfrom launch.actions import ExecuteProcess\nimport os\n\n\ndef generate_launch_description():\n    # Get the package share directory\n    pkg_share = get_package_share_directory('humanoid_description')\n\n    # Define the URDF file path\n    default_model_path = os.path.join(pkg_share, 'urdf/simple_humanoid.urdf')\n\n    # Define the world file path\n    default_world_path = os.path.join(pkg_share, 'worlds/empty_world.world')\n\n    # Declare launch arguments\n    model_arg = DeclareLaunchArgument(\n        name='model',\n        default_value=default_model_path,\n        description='Absolute path to robot urdf file'\n    )\n\n    world_arg = DeclareLaunchArgument(\n        name='world',\n        default_value=default_world_path,\n        description='Absolute path to world file'\n    )\n\n    # Start Gazebo server and client\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': LaunchConfiguration('world'),\n            'verbose': 'false',\n        }.items()\n    )\n\n    # Robot State Publisher node\n    robot_state_publisher_node = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        parameters=[{\n            'robot_description': open(default_model_path).read()\n        }]\n    )\n\n    # Spawn the robot in Gazebo\n    spawn_entity_node = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'simple_humanoid',\n            '-x', '0.0',\n            '-y', '0.0',\n            '-z', '1.0'\n        ],\n        output='screen'\n    )\n\n    # Joint State Publisher GUI node\n    joint_state_publisher_gui_node = Node(\n        package='joint_state_publisher_gui',\n        executable='joint_state_publisher_gui',\n        name='joint_state_publisher_gui',\n        output='screen'\n    )\n\n    # RViz2 node\n    rviz_node = Node(\n        package='rviz2',\n        executable='rviz2',\n        name='rviz2',\n        output='screen'\n    )\n\n    return LaunchDescription([\n        model_arg,\n        world_arg,\n        gazebo,\n        robot_state_publisher_node,\n        spawn_entity_node,\n        joint_state_publisher_gui_node,\n        rviz_node\n    ])\n"})}),"\n",(0,t.jsxs)(e.ol,{start:"4",children:["\n",(0,t.jsxs)(e.li,{children:["Create a new launch file specifically for Gazebo simulation with ros2_control integration at ",(0,t.jsx)(e.code,{children:"humanoid_description/launch/gazebo_simulation.launch.py"}),":"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution, Command\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch.event_handlers import OnProcessExit\nfrom launch.actions import ExecuteProcess\nimport os\n\n\ndef generate_launch_description():\n    # Get the package share directory\n    pkg_share = get_package_share_directory('humanoid_description')\n    default_model_path = os.path.join(pkg_share, 'urdf/simple_humanoid.urdf')\n    default_world_path = os.path.join(pkg_share, 'worlds/empty_world.world')\n\n    # Declare launch arguments\n    model_arg = DeclareLaunchArgument(\n        name='model',\n        default_value=default_model_path,\n        description='Absolute path to robot urdf file'\n    )\n\n    world_arg = DeclareLaunchArgument(\n        name='world',\n        default_value=default_world_path,\n        description='Absolute path to world file'\n    )\n\n    # Start Gazebo server and client\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': LaunchConfiguration('world'),\n            'verbose': 'false',\n        }.items()\n    )\n\n    # Robot State Publisher node\n    robot_state_publisher_node = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        parameters=[{\n            'robot_description': Command(['xacro ', LaunchConfiguration('model')])\n        }]\n    )\n\n    # Spawn the robot in Gazebo with ros2_control plugin\n    spawn_entity_node = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'simple_humanoid',\n            '-x', '0.0',\n            '-y', '0.0',\n            '-z', '1.0'\n        ],\n        output='screen'\n    )\n\n    # ros2_control Node\n    ros2_controllers_path = os.path.join(\n        get_package_share_directory('humanoid_description'),\n        'config',\n        'controllers.yaml'\n    )\n\n    # Create controllers.yaml configuration file\n    controllers_config = \"\"\"\n    controller_manager:\n      ros__parameters:\n        update_rate: 100  # Hz\n\n        joint_state_broadcaster:\n          type: joint_state_broadcaster/JointStateBroadcaster\n\n        joint_trajectory_controller:\n          type: joint_trajectory_controller/JointTrajectoryController\n          joints:\n            - left_shoulder\n            - left_elbow\n            - right_shoulder\n            - right_elbow\n            - left_hip\n            - left_knee\n            - right_hip\n            - right_knee\n    \"\"\"\n\n    # Write controllers.yaml to the config directory\n    config_dir = os.path.join(get_package_share_directory('humanoid_description'), 'config')\n    os.makedirs(config_dir, exist_ok=True)\n    controllers_file = os.path.join(config_dir, 'controllers.yaml')\n    with open(controllers_file, 'w') as f:\n        f.write(controllers_config)\n\n    # Load the controllers\n    load_joint_state_broadcaster = ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller', '--set-state', 'start', 'joint_state_broadcaster'],\n        output='screen'\n    )\n\n    load_joint_trajectory_controller = ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller', '--set-state', 'start', 'joint_trajectory_controller'],\n        output='screen'\n    )\n\n    # RViz2 node\n    rviz_config_file = PathJoinSubstitution(\n        [FindPackageShare('humanoid_description'), 'rviz', 'display.rviz']\n    )\n\n    rviz_node = Node(\n        package='rviz2',\n        executable='rviz2',\n        name='rviz2',\n        output='screen'\n    )\n\n    return LaunchDescription([\n        model_arg,\n        world_arg,\n        gazebo,\n        robot_state_publisher_node,\n        spawn_entity_node,\n        RegisterEventHandler(\n            event_handler=OnProcessExit(\n                target_action=spawn_entity_node,\n                on_exit=[load_joint_state_broadcaster],\n            )\n        ),\n        RegisterEventHandler(\n            event_handler=OnProcessExit(\n                target_action=load_joint_state_broadcaster,\n                on_exit=[load_joint_trajectory_controller],\n            )\n        ),\n        rviz_node\n    ])\n"})}),"\n",(0,t.jsxs)(e.ol,{start:"5",children:["\n",(0,t.jsx)(e.li,{children:"Update the humanoid_description package CMakeLists.txt to install worlds directory:"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cmake",children:'cmake_minimum_required(VERSION 3.8)\nproject(humanoid_description)\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\n# find dependencies\nfind_package(ament_cmake REQUIRED)\nfind_package(urdf REQUIRED)\nfind_package(xacro REQUIRED)\n\n# Install launch files\ninstall(DIRECTORY launch\n  DESTINATION share/${PROJECT_NAME}\n)\n\n# Install URDF files\ninstall(DIRECTORY urdf\n  DESTINATION share/${PROJECT_NAME}\n)\n\n# Install worlds files\ninstall(DIRECTORY worlds\n  DESTINATION share/${PROJECT_NAME}\n)\n\n# Install config files\ninstall(DIRECTORY config\n  DESTINATION share/${PROJECT_NAME}\n)\n\n# Install rviz files\ninstall(DIRECTORY rviz\n  DESTINATION share/${PROJECT_NAME}\n)\n\nif(BUILD_TESTING)\n  find_package(ament_lint_auto REQUIRED)\n  ament_lint_auto_find_test_dependencies()\nendif()\n\nament_package()\n'})}),"\n",(0,t.jsxs)(e.ol,{start:"6",children:["\n",(0,t.jsx)(e.li,{children:"Build the package:"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"cd ~/robotics_ws\ncolcon build --packages-select humanoid_description\nsource install/setup.bash\n"})}),"\n",(0,t.jsxs)(e.ol,{start:"7",children:["\n",(0,t.jsx)(e.li,{children:"Test the Gazebo simulation:"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"ros2 launch humanoid_description gazebo_simulation.launch.py\n"})}),"\n",(0,t.jsx)(e.h2,{id:"safety-notes",children:"Safety Notes"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Always test simulation parameters to ensure stable physics behavior"}),"\n",(0,t.jsx)(e.li,{children:"Verify joint limits and safety constraints are properly configured"}),"\n",(0,t.jsx)(e.li,{children:"Monitor simulation real-time factor to ensure performance"}),"\n",(0,t.jsx)(e.li,{children:"Use proper collision detection settings to avoid interpenetration"}),"\n",(0,t.jsx)(e.li,{children:"Implement emergency stop mechanisms in simulation controllers"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"evaluation-criteria",children:"Evaluation Criteria"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Can you successfully launch the humanoid robot in Gazebo?"}),"\n",(0,t.jsx)(e.li,{children:"Are the ros2_control interfaces properly connected to the simulated robot?"}),"\n",(0,t.jsx)(e.li,{children:"Can you command joint movements and see the robot respond in simulation?"}),"\n",(0,t.jsx)(e.li,{children:"Is the simulation running at stable real-time performance?"}),"\n",(0,t.jsx)(e.li,{children:"Are joint states properly published from the simulated robot?"}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>a,x:()=>s});var i=o(6540);const t={},r=i.createContext(t);function a(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);