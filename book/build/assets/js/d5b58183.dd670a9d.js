"use strict";(globalThis.webpackChunkbook_temp=globalThis.webpackChunkbook_temp||[]).push([[103],{8453:(n,i,e)=>{e.d(i,{R:()=>s,x:()=>r});var a=e(6540);const o={},t=a.createContext(o);function s(n){const i=a.useContext(t);return a.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function r(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),a.createElement(t.Provider,{value:i},n.children)}},9027:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"module_3/3_4_sim_to_real","title":"Sim-to-Real Transfer","description":"Purpose","source":"@site/docs/03_module_3/3_4_sim_to_real.mdx","sourceDirName":"03_module_3","slug":"/module_3/3_4_sim_to_real","permalink":"/physical-ai-humanoid-robotics-book/docs/module_3/3_4_sim_to_real","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/03_module_3/3_4_sim_to_real.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Sim-to-Real Transfer"},"sidebar":"tutorialSidebar","previous":{"title":"Navigation & Motion Planning (Nav2)","permalink":"/physical-ai-humanoid-robotics-book/docs/module_3/3_3_nav2"},"next":{"title":"Chapter 4.1: Voice Input with Whisper","permalink":"/physical-ai-humanoid-robotics-book/docs/module_4/4_1_whisper_voice"}}');var o=e(4848),t=e(8453);const s={sidebar_position:4,title:"Sim-to-Real Transfer"},r="Sim-to-Real Transfer",l={},d=[{value:"Purpose",id:"purpose",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Outputs",id:"outputs",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Chapter Outline",id:"chapter-outline",level:2},{value:"1. Understanding Reality Gaps",id:"1-understanding-reality-gaps",level:3},{value:"2. Domain Randomization Techniques",id:"2-domain-randomization-techniques",level:3},{value:"3. System Identification and Model Calibration",id:"3-system-identification-and-model-calibration",level:3},{value:"4. Transfer Validation and Deployment",id:"4-transfer-validation-and-deployment",level:3},{value:"Hands-On Lab",id:"hands-on-lab",level:2},{value:"Implementing Sim-to-Real Transfer Strategies",id:"implementing-sim-to-real-transfer-strategies",level:3},{value:"Safety Notes",id:"safety-notes",level:2},{value:"Evaluation Criteria",id:"evaluation-criteria",level:2}];function m(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"sim-to-real-transfer",children:"Sim-to-Real Transfer"})}),"\n",(0,o.jsx)(i.h2,{id:"purpose",children:"Purpose"}),"\n",(0,o.jsx)(i.p,{children:"This chapter addresses the critical challenge of transferring policies and behaviors learned in simulation to real-world robotic systems. We'll explore domain randomization techniques, reality gap mitigation strategies, and systematic approaches to validate and deploy simulation-trained models on physical humanoid robots. The chapter emphasizes practical methodologies for achieving robust sim-to-real transfer."}),"\n",(0,o.jsx)(i.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(i.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Implement domain randomization techniques to improve sim-to-real transfer"}),"\n",(0,o.jsx)(i.li,{children:"Identify and mitigate reality gaps between simulation and physical systems"}),"\n",(0,o.jsx)(i.li,{children:"Design systematic validation approaches for transferring policies"}),"\n",(0,o.jsx)(i.li,{children:"Apply system identification methods to match simulation to reality"}),"\n",(0,o.jsx)(i.li,{children:"Evaluate transfer performance and quantify success metrics"}),"\n",(0,o.jsx)(i.li,{children:"Understand the limitations and constraints of sim-to-real approaches"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Completed Module 1 (ROS 2 fundamentals and humanoid URDF)"}),"\n",(0,o.jsx)(i.li,{children:"Completed Module 2 (Gazebo & Unity digital twin)"}),"\n",(0,o.jsx)(i.li,{children:"Completed Module 3.1-3.3 (Isaac Sim, perception, and navigation)"}),"\n",(0,o.jsx)(i.li,{children:"Understanding of machine learning and reinforcement learning concepts"}),"\n",(0,o.jsx)(i.li,{children:"Experience with system identification and parameter tuning"}),"\n",(0,o.jsx)(i.li,{children:"Knowledge of physical robot safety protocols"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"inputs",children:"Inputs"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Simulation-trained policies from previous modules"}),"\n",(0,o.jsx)(i.li,{children:"Physical humanoid robot platform specifications"}),"\n",(0,o.jsx)(i.li,{children:"Understanding of system dynamics and constraints"}),"\n",(0,o.jsx)(i.li,{children:"Safety protocols for physical robot testing"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"outputs",children:"Outputs"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Domain randomization strategies for simulation"}),"\n",(0,o.jsx)(i.li,{children:"Reality gap analysis and mitigation approaches"}),"\n",(0,o.jsx)(i.li,{children:"Validation methodologies for sim-to-real transfer"}),"\n",(0,o.jsx)(i.li,{children:"Performance metrics for transfer success"}),"\n",(0,o.jsx)(i.li,{children:"Safety guidelines for physical robot deployment"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Domain Randomization"}),": Technique to improve sim-to-real transfer by randomizing simulation parameters"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Reality Gap"}),": Differences between simulation and real-world behavior that affect transfer"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"System Identification"}),": Process of determining physical system parameters for accurate simulation"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Transfer Learning"}),": Adapting simulation-trained models for real-world use"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Validation Protocols"}),": Systematic approaches to test and validate transfer success"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Safety Considerations"}),": Protocols to ensure safe transition from simulation to reality"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Performance Metrics"}),": Quantitative measures for evaluating transfer effectiveness"]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"chapter-outline",children:"Chapter Outline"}),"\n",(0,o.jsx)(i.p,{children:"This chapter addresses sim-to-real transfer challenges:"}),"\n",(0,o.jsx)(i.h3,{id:"1-understanding-reality-gaps",children:"1. Understanding Reality Gaps"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Sources of simulation-reality discrepancies"}),"\n",(0,o.jsx)(i.li,{children:"Quantifying differences in dynamics, sensors, and environment"}),"\n",(0,o.jsx)(i.li,{children:"Impact on policy transfer performance"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"2-domain-randomization-techniques",children:"2. Domain Randomization Techniques"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Randomizing physical parameters in simulation"}),"\n",(0,o.jsx)(i.li,{children:"Environmental variation strategies"}),"\n",(0,o.jsx)(i.li,{children:"Sensor noise and uncertainty modeling"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"3-system-identification-and-model-calibration",children:"3. System Identification and Model Calibration"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Matching simulation to physical system dynamics"}),"\n",(0,o.jsx)(i.li,{children:"Parameter estimation methods"}),"\n",(0,o.jsx)(i.li,{children:"Validation and verification approaches"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"4-transfer-validation-and-deployment",children:"4. Transfer Validation and Deployment"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Systematic testing protocols"}),"\n",(0,o.jsx)(i.li,{children:"Safety considerations for physical deployment"}),"\n",(0,o.jsx)(i.li,{children:"Performance evaluation metrics"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"hands-on-lab",children:"Hands-On Lab"}),"\n",(0,o.jsx)(i.h3,{id:"implementing-sim-to-real-transfer-strategies",children:"Implementing Sim-to-Real Transfer Strategies"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.strong,{children:"Reality Gap Analysis:"}),"\nUnderstanding the differences between simulation and reality is crucial for successful transfer:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Dynamics Differences"}),": Simulation may not perfectly model friction, compliance, or complex interactions"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Sensor Noise"}),": Real sensors have noise, latency, and accuracy limitations not present in simulation"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Actuator Limitations"}),": Physical actuators have delays, bandwidth limitations, and saturation effects"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Environmental Factors"}),": Real environments have lighting variations, surface irregularities, and dynamic elements"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.strong,{children:"Domain Randomization Implementation:"}),"\nCreate a domain randomization configuration for Isaac Sim: ",(0,o.jsx)(i.code,{children:"isaac_sim_assets/configs/domain_randomization_config.py"})]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'"""\nDomain Randomization Configuration for Isaac Sim\n\nThis script configures domain randomization parameters in Isaac Sim\nto improve sim-to-real transfer by training policies across diverse conditions.\n"""\n\nimport omni\nimport carb\nimport numpy as np\nfrom pxr import Gf, Sdf, UsdGeom\nimport random\n\n\nclass DomainRandomizationConfig:\n    def __init__(self):\n        self.config = {\n            # Physical properties randomization\n            \'mass_range\': (0.8, 1.2),  # Multiplier for object masses\n            \'friction_range\': (0.4, 1.0),  # Range for friction coefficients\n            \'restitution_range\': (0.1, 0.5),  # Range for restitution coefficients\n\n            # Visual appearance randomization\n            \'light_intensity_range\': (0.5, 2.0),  # Range for light intensities\n            \'material_color_range\': (0.0, 1.0),  # Range for material colors\n            \'texture_scale_range\': (0.8, 1.2),  # Range for texture scaling\n\n            # Sensor noise and parameters\n            \'camera_noise_range\': (0.0, 0.05),  # Range for camera noise\n            \'lidar_noise_range\': (0.0, 0.02),  # Range for LiDAR noise\n\n            # Environmental parameters\n            \'gravity_range\': (-10.0, -9.5),  # Range for gravity magnitude\n            \'wind_force_range\': (0.0, 0.5),  # Range for wind forces\n        }\n\n    def apply_randomization(self, stage):\n        """\n        Apply domain randomization to the current USD stage\n        """\n        carb.log_info("Applying domain randomization to USD stage")\n\n        # Randomize physical properties\n        self.randomize_masses(stage)\n        self.randomize_friction(stage)\n        self.randomize_restitution(stage)\n\n        # Randomize visual properties\n        self.randomize_lighting(stage)\n        self.randomize_materials(stage)\n\n        # Randomize environmental conditions\n        self.randomize_environment(stage)\n\n        carb.log_info("Domain randomization applied successfully")\n\n    def randomize_masses(self, stage):\n        """Randomize masses of rigid bodies"""\n        carb.log_info("Randomizing masses")\n        # In a real implementation, this would iterate through all rigid bodies\n        # and apply random multipliers within the specified range\n\n    def randomize_friction(self, stage):\n        """Randomize friction coefficients"""\n        carb.log_info("Randomizing friction coefficients")\n        # In a real implementation, this would modify friction parameters\n        # of collision materials\n\n    def randomize_restitution(self, stage):\n        """Randomize restitution coefficients"""\n        carb.log_info("Randomizing restitution coefficients")\n        # In a real implementation, this would modify bounciness parameters\n\n    def randomize_lighting(self, stage):\n        """Randomize lighting conditions"""\n        carb.log_info("Randomizing lighting conditions")\n        # In a real implementation, this would modify light intensities\n        # and colors within the specified ranges\n\n    def randomize_materials(self, stage):\n        """Randomize material properties"""\n        carb.log_info("Randomizing material properties")\n        # In a real implementation, this would modify material colors\n        # and textures within the specified ranges\n\n    def randomize_environment(self, stage):\n        """Randomize environmental conditions"""\n        carb.log_info("Randomizing environmental conditions")\n        # In a real implementation, this would modify gravity, wind, etc.\n\n\ndef setup_domain_randomization():\n    """\n    Set up domain randomization in Isaac Sim\n    """\n    carb.log_info("Setting up domain randomization pipeline")\n\n    # Create domain randomization config\n    dr_config = DomainRandomizationConfig()\n\n    # Get current stage\n    stage = omni.usd.get_context().get_stage()\n\n    # Apply randomization\n    dr_config.apply_randomization(stage)\n\n    carb.log_info("Domain randomization setup completed")\n\n\ndef update_randomization_periodically():\n    """\n    Function to periodically update randomization during training\n    """\n    carb.log_info("Setting up periodic domain randomization updates")\n\n    # This would typically be called at regular intervals during training\n    # to continuously randomize the simulation environment\n    stage = omni.usd.get_context().get_stage()\n    dr_config = DomainRandomizationConfig()\n    dr_config.apply_randomization(stage)\n\n\nif __name__ == "__main__":\n    setup_domain_randomization()\n'})}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.strong,{children:"System Identification for Model Calibration:"}),"\nCreate a system identification approach to match simulation to reality: ",(0,o.jsx)(i.code,{children:"robotics_ws/src/humanoid_nav2_config/config/system_identification.md"})]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-markdown",children:"# System Identification for Sim-to-Real Transfer\n\n## Purpose\nThis document outlines the process of identifying and calibrating system parameters to minimize the reality gap between simulation and physical humanoid robot.\n\n## Parameters to Identify\n\n### Physical Properties\n- **Mass Properties**: Individual link masses, centers of mass, and inertial properties\n- **Joint Properties**: Gear ratios, friction coefficients, compliance parameters\n- **Actuator Properties**: Torque constants, dead zones, bandwidth limitations\n\n### Sensor Properties\n- **Camera Calibration**: Intrinsic and extrinsic parameters, distortion coefficients\n- **LiDAR Calibration**: Range accuracy, angular resolution, noise characteristics\n- **IMU Calibration**: Bias, scale factor, alignment errors\n\n### Environmental Properties\n- **Surface Properties**: Friction coefficients, compliance, texture\n- **Gravity**: Local gravity magnitude and direction\n- **Air Resistance**: Drag coefficients for different body parts\n\n## Identification Process\n\n1. **Data Collection**\n   - Collect synchronized sensor and actuator data from physical robot\n   - Perform controlled experiments (e.g., step responses, frequency sweeps)\n   - Record multiple trials for statistical significance\n\n2. **Parameter Estimation**\n   - Use system identification techniques (e.g., least squares, maximum likelihood)\n   - Estimate parameters that minimize prediction error\n   - Validate model on held-out test data\n\n3. **Simulation Update**\n   - Update simulation parameters with identified values\n   - Verify that simulation behavior matches physical system\n   - Iterate until sufficient match is achieved\n\n## Validation Metrics\n\n- **Position Tracking Error**: RMS error between simulated and real joint positions\n- **Velocity Tracking Error**: RMS error between simulated and real joint velocities\n- **Prediction Accuracy**: How well simulation predicts real behavior\n- **Control Performance**: Similarity in control effort and response characteristics\n"})}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.strong,{children:"Transfer Validation Protocol:"}),"\nCreate a validation approach document: ",(0,o.jsx)(i.code,{children:"robotics_ws/src/humanoid_nav2_config/config/transfer_validation.md"})]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-markdown",children:"# Sim-to-Real Transfer Validation Protocol\n\n## Purpose\nThis protocol defines systematic approaches to validate successful transfer of simulation-trained policies to physical humanoid robots.\n\n## Pre-Transfer Validation\n\n1. **Simulation Performance Verification**\n   - Ensure policy performs consistently in varied simulation conditions\n   - Test with domain randomization parameters\n   - Validate safety and stability margins\n\n2. **Safety Precautions**\n   - Implement position, velocity, and torque limits\n   - Set up emergency stop procedures\n   - Verify physical robot safety systems\n\n3. **Gradual Deployment**\n   - Start with open-loop execution of planned trajectories\n   - Progress to closed-loop control with safety limits\n   - Gradually increase autonomy level\n\n## Transfer Testing Phases\n\n### Phase 1: Open-Loop Testing\n- Execute pre-planned trajectories on physical robot\n- Compare to simulation execution\n- Measure tracking accuracy and deviations\n\n### Phase 2: Closed-Loop Testing\n- Enable closed-loop control with safety limits\n- Test basic behaviors and reactions\n- Monitor for unexpected behaviors\n\n### Phase 3: Full Policy Execution\n- Deploy full simulation-trained policy\n- Monitor performance metrics\n- Collect data for further analysis\n\n## Performance Metrics\n\n- **Success Rate**: Percentage of tasks completed successfully\n- **Execution Time**: Time to complete tasks compared to simulation\n- **Energy Efficiency**: Power consumption compared to simulation predictions\n- **Safety Violations**: Number of safety limit activations\n- **Tracking Error**: Deviation from expected behavior\n\n## Safety Considerations\n\n- Never exceed physical robot safety limits\n- Have human operator ready to intervene\n- Start with conservative parameters and gradually increase\n- Monitor robot health and temperature\n- Use protective equipment and safe testing environment\n"})}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.strong,{children:"Simulation-Reality Comparison Framework:"}),"\nCreate a comparison framework to evaluate transfer: ",(0,o.jsx)(i.code,{children:"robotics_ws/src/humanoid_nav2_config/scripts/sim_real_comparison.py"})]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:"#!/usr/bin/env python3\n\n\"\"\"\nSimulation-Reality Comparison Framework\n\nThis script provides tools to compare simulation and real-world robot behavior\nfor validating sim-to-real transfer.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom nav_msgs.msg import Odometry\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial.transform import Rotation as R\n\n\nclass SimRealComparison(Node):\n    def __init__(self):\n        super().__init__('sim_real_comparison')\n\n        # Subscribers for simulation and real robot data\n        self.sim_joint_sub = self.create_subscription(\n            JointState,\n            '/sim/joint_states',\n            self.sim_joint_callback,\n            10\n        )\n\n        self.real_joint_sub = self.create_subscription(\n            JointState,\n            '/real/joint_states',\n            self.real_joint_callback,\n            10\n        )\n\n        self.sim_odom_sub = self.create_subscription(\n            Odometry,\n            '/sim/odom',\n            self.sim_odom_callback,\n            10\n        )\n\n        self.real_odom_sub = self.create_subscription(\n            Odometry,\n            '/real/odom',\n            self.real_odom_callback,\n            10\n        )\n\n        # Storage for comparison data\n        self.sim_joint_data = []\n        self.real_joint_data = []\n        self.sim_odom_data = []\n        self.real_odom_data = []\n\n        # Timing\n        self.start_time = self.get_clock().now()\n\n        self.get_logger().info(\"Simulation-Reality Comparison Node initialized\")\n\n    def sim_joint_callback(self, msg):\n        \"\"\"Process simulation joint state data\"\"\"\n        self.sim_joint_data.append({\n            'timestamp': msg.header.stamp,\n            'positions': np.array(msg.position),\n            'velocities': np.array(msg.velocity),\n            'effort': np.array(msg.effort)\n        })\n\n    def real_joint_callback(self, msg):\n        \"\"\"Process real robot joint state data\"\"\"\n        self.real_joint_data.append({\n            'timestamp': msg.header.stamp,\n            'positions': np.array(msg.position),\n            'velocities': np.array(msg.velocity),\n            'effort': np.array(msg.effort)\n        })\n\n    def sim_odom_callback(self, msg):\n        \"\"\"Process simulation odometry data\"\"\"\n        self.sim_odom_data.append({\n            'timestamp': msg.header.stamp,\n            'position': np.array([msg.pose.pose.position.x, msg.pose.pose.position.y, msg.pose.pose.position.z]),\n            'orientation': [msg.pose.pose.orientation.x, msg.pose.pose.orientation.y,\n                           msg.pose.pose.orientation.z, msg.pose.pose.orientation.w]\n        })\n\n    def real_odom_callback(self, msg):\n        \"\"\"Process real robot odometry data\"\"\"\n        self.real_odom_data.append({\n            'timestamp': msg.header.stamp,\n            'position': np.array([msg.pose.pose.position.x, msg.pose.pose.position.y, msg.pose.pose.position.z]),\n            'orientation': [msg.pose.pose.orientation.x, msg.pose.pose.orientation.y,\n                           msg.pose.pose.orientation.z, msg.pose.pose.orientation.w]\n        })\n\n    def compute_comparison_metrics(self):\n        \"\"\"Compute metrics comparing simulation and real data\"\"\"\n        if len(self.sim_joint_data) == 0 or len(self.real_joint_data) == 0:\n            self.get_logger().warn(\"Insufficient data for comparison\")\n            return\n\n        # Align data by time\n        sim_positions = np.array([d['positions'] for d in self.sim_joint_data])\n        real_positions = np.array([d['positions'] for d in self.real_joint_data])\n\n        # Truncate to same length\n        min_len = min(len(sim_positions), len(real_positions))\n        sim_pos = sim_positions[:min_len]\n        real_pos = real_positions[:min_len]\n\n        # Compute position tracking error\n        pos_error = np.mean(np.abs(sim_pos - real_pos))\n        self.get_logger().info(f\"Average position tracking error: {pos_error:.4f}\")\n\n        # Compute RMS error\n        rms_error = np.sqrt(np.mean((sim_pos - real_pos)**2))\n        self.get_logger().info(f\"RMS position tracking error: {rms_error:.4f}\")\n\n        return {\n            'mean_error': pos_error,\n            'rms_error': rms_error\n        }\n\n    def plot_comparison(self):\n        \"\"\"Plot comparison between simulation and real data\"\"\"\n        if len(self.sim_joint_data) == 0 or len(self.real_joint_data) == 0:\n            self.get_logger().warn(\"Insufficient data for plotting\")\n            return\n\n        # Extract position data\n        sim_positions = np.array([d['positions'] for d in self.sim_joint_data])\n        real_positions = np.array([d['positions'] for d in self.real_joint_data])\n\n        # Truncate to same length\n        min_len = min(len(sim_positions), len(real_positions))\n        sim_pos = sim_positions[:min_len]\n        real_pos = real_positions[:min_len]\n\n        # Plot comparison\n        fig, axes = plt.subplots(min(sim_pos.shape[1], 4), 1, figsize=(10, 8))\n        if sim_pos.shape[1] == 1:\n            axes = [axes]\n\n        for i in range(min(sim_pos.shape[1], 4)):\n            axes[i].plot(sim_pos[:, i], label=f'Simulation Joint {i}', alpha=0.7)\n            axes[i].plot(real_pos[:, i], label=f'Real Joint {i}', alpha=0.7)\n            axes[i].set_title(f'Joint {i} Position Comparison')\n            axes[i].legend()\n            axes[i].grid(True)\n\n        plt.tight_layout()\n        plt.savefig('/tmp/sim_real_comparison.png')\n        self.get_logger().info(\"Comparison plot saved to /tmp/sim_real_comparison.png\")\n        plt.show()\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    comparison_node = SimRealComparison()\n\n    # Run for a fixed duration to collect data\n    timer = comparison_node.create_timer(10.0, lambda: rclpy.shutdown())\n\n    try:\n        rclpy.spin(comparison_node)\n    except KeyboardInterrupt:\n        comparison_node.get_logger().info(\"Shutting down comparison node\")\n\n    # Compute final metrics\n    metrics = comparison_node.compute_comparison_metrics()\n    comparison_node.plot_comparison()\n\n    comparison_node.destroy_node()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.strong,{children:"Domain Randomization in Isaac Sim:"}),"\nCreate a more detailed domain randomization script for Isaac Sim: ",(0,o.jsx)(i.code,{children:"isaac_sim_assets/scripts/domain_randomization.py"})]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'"""\nAdvanced Domain Randomization for Isaac Sim\n\nThis script implements advanced domain randomization techniques\nto improve sim-to-real transfer capabilities for humanoid robots.\n"""\n\nimport omni\nimport omni.kit.commands\nimport carb\nimport numpy as np\nimport random\nfrom pxr import Usd, UsdGeom, Gf, Sdf, UsdPhysics, PhysxSchema\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nfrom omni.isaac.core.utils.prims import get_prim_at_path\nfrom omni.isaac.core.utils.viewports import set_camera_view\nfrom omni.isaac.core import World\nfrom omni.isaac.core.robots import Robot\nfrom omni.isaac.core.utils.semantics import add_semantic_label\n\n\nclass AdvancedDomainRandomization:\n    def __init__(self):\n        self.world = World()\n        self.stage = omni.usd.get_context().get_stage()\n\n        # Define randomization ranges\n        self.mass_range = (0.8, 1.2)\n        self.friction_range = (0.4, 1.0)\n        self.restitution_range = (0.1, 0.5)\n        self.damping_range = (0.01, 0.1)\n        self.stiffness_range = (100, 1000)\n\n        # Visual randomization\n        self.light_intensity_range = (0.5, 2.0)\n        self.material_color_range = (0.0, 1.0)\n        self.texture_scale_range = (0.8, 1.2)\n\n        # Sensor randomization\n        self.camera_noise_range = (0.0, 0.05)\n        self.lidar_noise_range = (0.0, 0.02)\n\n    def randomize_robot_dynamics(self):\n        """Randomize the dynamics properties of the humanoid robot"""\n        carb.log_info("Randomizing humanoid robot dynamics")\n\n        # Get robot prims\n        robot_paths = [\n            "/World/humanoid_robot/base_link",\n            "/World/humanoid_robot/torso",\n            "/World/humanoid_robot/head",\n            "/World/humanoid_robot/left_arm",\n            "/World/humanoid_robot/right_arm",\n            "/World/humanoid_robot/left_leg",\n            "/World/humanoid_robot/right_leg"\n        ]\n\n        for path in robot_paths:\n            prim = self.stage.GetPrimAtPath(path)\n            if not prim.IsValid():\n                continue\n\n            # Randomize mass\n            random_mass = random.uniform(*self.mass_range)\n            if prim.HasAPI(UsdPhysics.MassAPI):\n                mass_api = UsdPhysics.MassAPI(prim)\n                mass_attr = mass_api.GetMassAttr()\n                original_mass = mass_attr.Get()\n                new_mass = original_mass * random_mass\n                mass_attr.Set(new_mass)\n\n            # Randomize friction\n            random_friction = random.uniform(*self.friction_range)\n            if prim.HasAPI(UsdPhysics.MaterialAPI):\n                material_api = UsdPhysics.MaterialAPI(prim)\n                friction_attr = material_api.GetStaticFrictionAttr()\n                friction_attr.Set(random_friction)\n\n            # Randomize restitution\n            random_restitution = random.uniform(*self.restitution_range)\n            if prim.HasAPI(UsdPhysics.MaterialAPI):\n                material_api = UsdPhysics.MaterialAPI(prim)\n                restitution_attr = material_api.GetRestitutionAttr()\n                restitution_attr.Set(random_restitution)\n\n        carb.log_info("Robot dynamics randomization completed")\n\n    def randomize_environment(self):\n        """Randomize environmental conditions"""\n        carb.log_info("Randomizing environmental conditions")\n\n        # Randomize gravity\n        gravity_magnitude = random.uniform(9.5, 10.0)\n        physics_scene_path = Sdf.Path("/World/physicsScene")\n        physics_scene = UsdPhysics.Scene.Get(self.stage, physics_scene_path)\n        if physics_scene:\n            gravity_attr = physics_scene.GetGravityMagnitudeAttr()\n            gravity_attr.Set(gravity_magnitude)\n\n        # Randomize lighting conditions\n        light_prims = [prim for prim in self.stage.TraverseAll()\n                      if prim.GetTypeName() in ["DistantLight", "DomeLight"]]\n\n        for light_prim in light_prims:\n            light_api = UsdGeom.Light(light_prim)\n            intensity_attr = light_api.GetIntensityAttr()\n            original_intensity = intensity_attr.Get()\n            random_multiplier = random.uniform(*self.light_intensity_range)\n            new_intensity = original_intensity * random_multiplier\n            intensity_attr.Set(new_intensity)\n\n        carb.log_info("Environmental randomization completed")\n\n    def randomize_sensors(self):\n        """Randomize sensor properties to simulate real-world noise"""\n        carb.log_info("Randomizing sensor properties")\n\n        # This would typically involve configuring Isaac Sim\'s sensor nodes\n        # to add noise, latency, and other real-world characteristics\n        # In a real implementation, we would access the sensor nodes directly\n        # and modify their noise parameters\n\n        # For demonstration, we\'ll log what would be randomized\n        camera_noise = random.uniform(*self.camera_noise_range)\n        lidar_noise = random.uniform(*self.lidar_noise_range)\n\n        carb.log_info(f"Camera noise level: {camera_noise}")\n        carb.log_info(f"LiDAR noise level: {lidar_noise}")\n\n    def apply_randomization(self):\n        """Apply all domain randomization techniques"""\n        carb.log_info("Applying advanced domain randomization")\n\n        self.randomize_robot_dynamics()\n        self.randomize_environment()\n        self.randomize_sensors()\n\n        carb.log_info("Advanced domain randomization applied successfully")\n\n    def update_randomization_periodically(self):\n        """Update randomization at regular intervals during training"""\n        # This would be called periodically during RL training\n        # to continuously randomize the environment\n        self.apply_randomization()\n\n\ndef setup_advanced_domain_randomization():\n    """Setup function to initialize advanced domain randomization"""\n    carb.log_info("Setting up advanced domain randomization")\n\n    # Create the domain randomization manager\n    dr_manager = AdvancedDomainRandomization()\n\n    # Apply initial randomization\n    dr_manager.apply_randomization()\n\n    # Set up periodic updates (in a real implementation)\n    # This would typically be done through Isaac Sim\'s update loop\n    # omni.kit.app.get_app().get_update_event_stream().create_subscription_to_pop(\n    #     lambda e: dr_manager.update_randomization_periodically()\n    # )\n\n    carb.log_info("Advanced domain randomization setup completed")\n\n\nif __name__ == "__main__":\n    setup_advanced_domain_randomization()\n'})}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Testing the Sim-to-Real Transfer:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Implement domain randomization in Isaac Sim training"}),"\n",(0,o.jsx)(i.li,{children:"Train policies with randomized parameters"}),"\n",(0,o.jsx)(i.li,{children:"Validate policies in simulation with different randomization settings"}),"\n",(0,o.jsx)(i.li,{children:"Deploy to physical robot with appropriate safety measures"}),"\n",(0,o.jsx)(i.li,{children:"Compare performance metrics between simulation and reality"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"safety-notes",children:"Safety Notes"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Always implement safety limits and emergency stops when testing on physical robots"}),"\n",(0,o.jsx)(i.li,{children:"Gradually increase autonomy levels during transfer validation"}),"\n",(0,o.jsx)(i.li,{children:"Monitor robot health and environmental conditions during testing"}),"\n",(0,o.jsx)(i.li,{children:"Have human operators ready to intervene during physical testing"}),"\n",(0,o.jsx)(i.li,{children:"Document all safety procedures and ensure compliance with safety guidelines"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"evaluation-criteria",children:"Evaluation Criteria"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Does domain randomization improve the robustness of simulation-trained policies?"}),"\n",(0,o.jsx)(i.li,{children:"Can policies trained with domain randomization transfer successfully to physical robots?"}),"\n",(0,o.jsx)(i.li,{children:"Are the reality gap metrics within acceptable bounds?"}),"\n",(0,o.jsx)(i.li,{children:"Do safety protocols prevent dangerous behaviors during transfer?"}),"\n",(0,o.jsx)(i.li,{children:"Is the validation protocol systematic and reproducible?"}),"\n",(0,o.jsx)(i.li,{children:"Can performance be quantitatively measured and compared between simulation and reality?"}),"\n"]})]})}function c(n={}){const{wrapper:i}={...(0,t.R)(),...n.components};return i?(0,o.jsx)(i,{...n,children:(0,o.jsx)(m,{...n})}):m(n)}}}]);