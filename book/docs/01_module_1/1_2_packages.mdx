---
sidebar_position: 2
title: "Building ROS 2 Packages (Python / rclpy)"
---

# Building ROS 2 Packages (Python / rclpy)

## Purpose
This chapter builds on the foundational ROS 2 concepts and focuses on creating more sophisticated ROS 2 Python packages. It covers advanced node development, message types, services, and best practices for organizing robotics code using the rclpy client library.

## Learning Outcomes
After completing this chapter, you will be able to:
- Create complex ROS 2 Python packages with multiple nodes
- Implement services and actions for request-response communication
- Design custom message types for specific robotics applications
- Use parameters effectively in ROS 2 nodes
- Implement proper error handling and lifecycle management in ROS 2 nodes
- Structure robotics projects following ROS 2 best practices

## Prerequisites
- Understanding of basic ROS 2 concepts and node communication
- Experience with Python programming
- Completed Chapter 1.1: Foundations of Physical AI & ROS 2
- Working ROS 2 development environment

## Inputs
- Working ROS 2 installation (Humble Hawksbill or later)
- Basic ROS 2 package knowledge from Chapter 1.1
- Understanding of Python and object-oriented programming
- Access to the development environment set up in the lab guide

## Outputs
- Advanced ROS 2 Python package with multiple nodes
- Custom service implementation
- Parameter management system
- Well-structured robotics control package

## Key Concepts
- **rclpy**: The Python client library for ROS 2, providing Python bindings to ROS 2
- **Services**: Synchronous request-response communication pattern in ROS 2
- **Actions**: Asynchronous goal-oriented communication for long-running tasks
- **Parameters**: Dynamic configuration system for ROS 2 nodes
- **Node Composition**: Running multiple nodes in the same process
- **Lifecycle Nodes**: Nodes with well-defined states and transitions
- **ROS 2 Client Libraries**: Different language implementations (rclpy for Python, rclcpp for C++)

## Chapter Outline
This chapter progresses from basic node enhancement to advanced ROS 2 features:

### 1. Advanced Node Development
- Creating nodes with services
- Implementing parameter management
- Error handling and recovery strategies

### 2. Services and Actions
- Request-response communication patterns
- Designing custom service types
- Implementing action servers and clients

### 3. Message Types and Parameters
- Custom message definitions
- Parameter declarations and usage
- Dynamic parameter updates

### 4. Package Organization
- Best practices for structuring ROS 2 packages
- Resource management and cleanup
- Testing and debugging strategies

## Hands-On Lab
### Creating the Robot Control Basics Package
1. Navigate to your ROS 2 workspace:
```bash
cd ~/robotics_ws/src
```

2. Create a new package for robot control basics:
```bash
ros2 pkg create --build-type ament_python robot_control_basics
```

3. Create the velocity publisher node in `robot_control_basics/robot_control_basics/vel_publisher_node.py`:
```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from std_msgs.msg import Float64


class VelPublisherNode(Node):
    def __init__(self):
        super().__init__('vel_publisher')

        # Create publisher for cmd_vel topic
        self.vel_publisher = self.create_publisher(Twist, 'cmd_vel', 10)

        # Create subscriber for target velocity
        self.target_subscriber = self.create_subscription(
            Float64,
            'target_velocity',
            self.target_velocity_callback,
            10
        )

        # Declare parameters
        self.declare_parameter('linear_velocity', 0.5)
        self.declare_parameter('angular_velocity', 0.25)

        # Get parameter values
        self.linear_vel = self.get_parameter('linear_velocity').value
        self.angular_vel = self.get_parameter('angular_velocity').value

        # Timer for publishing velocity commands
        timer_period = 0.1  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

        self.get_logger().info('Velocity Publisher Node initialized')

    def target_velocity_callback(self, msg):
        self.linear_vel = msg.data
        self.get_logger().info(f'Updated linear velocity to: {self.linear_vel}')

    def timer_callback(self):
        msg = Twist()
        msg.linear.x = self.linear_vel
        msg.angular.z = self.angular_vel
        self.vel_publisher.publish(msg)
        self.get_logger().info(f'Publishing velocity: linear={msg.linear.x}, angular={msg.angular.z}')


def main(args=None):
    rclpy.init(args=args)
    node = VelPublisherNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

4. Create the scan subscriber node in `robot_control_basics/robot_control_basics/scan_subscriber_node.py`:
```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from std_msgs.msg import String


class ScanSubscriberNode(Node):
    def __init__(self):
        super().__init__('scan_subscriber')

        # Create subscriber for laser scan data
        self.scan_subscription = self.create_subscription(
            LaserScan,
            'scan',
            self.scan_callback,
            10
        )

        # Create publisher for obstacle detection
        self.obstacle_publisher = self.create_publisher(String, 'obstacle_alert', 10)

        # Declare parameters
        self.declare_parameter('obstacle_distance_threshold', 1.0)

        # Get parameter values
        self.threshold = self.get_parameter('obstacle_distance_threshold').value

        self.get_logger().info('Scan Subscriber Node initialized')

    def scan_callback(self, msg):
        # Check if any range reading is below the threshold
        min_distance = min(msg.ranges)

        if min_distance < self.threshold:
            alert_msg = String()
            alert_msg.data = f'OBSTACLE_DETECTED: {min_distance:.2f}m'
            self.obstacle_publisher.publish(alert_msg)
            self.get_logger().warn(f'Obstacle detected at {min_distance:.2f}m')
        else:
            self.get_logger().info(f'Clear path: {min_distance:.2f}m')


def main(args=None):
    rclpy.init(args=args)
    node = ScanSubscriberNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

5. Update the `setup.py` file in `robot_control_basics/setup.py`:
```python
import os
from glob import glob
from setuptools import setup
from setuptools import find_packages

package_name = 'robot_control_basics'

setup(
    name=package_name,
    version='0.0.0',
    packages=find_packages(exclude=['test']),
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Humanoid Robotics Book',
    maintainer_email='humanoid-robotics-book@example.com',
    description='Robot control basics for the Physical AI & Humanoid Robotics book',
    license='Apache License 2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'vel_publisher = robot_control_basics.vel_publisher_node:main',
            'scan_subscriber = robot_control_basics.scan_subscriber_node:main',
        ],
    },
)
```

6. Create the package.xml file in `robot_control_basics/package.xml`:
```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>robot_control_basics</name>
  <version>0.0.0</version>
  <description>Robot control basics for the Physical AI & Humanoid Robotics book</description>
  <maintainer email="humanoid-robotics-book@example.com">Humanoid Robotics Book</maintainer>
  <license>Apache-2.0</license>

  <depend>rclpy</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

7. Build the package:
```bash
cd ~/robotics_ws
colcon build --packages-select robot_control_basics
source install/setup.bash
```

## Safety Notes
- Always implement safety limits in velocity commands to prevent robot damage
- Use appropriate obstacle detection and avoidance strategies
- Test all control algorithms in simulation before physical robot deployment
- Implement emergency stop mechanisms in all control nodes
- Monitor robot behavior during testing and have manual override available

## Evaluation Criteria
- Can you successfully create and run the velocity publisher and scan subscriber nodes?
- Do you understand how to use ROS 2 parameters for configuration?
- Can you implement custom message handling for robot control?
- Are you able to use ROS 2 tools for debugging and monitoring?
- Can you structure a ROS 2 package following best practices?