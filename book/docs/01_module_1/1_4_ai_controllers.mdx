---
sidebar_position: 4
title: "Connecting AI Agents to ROS Controllers"
---

# Connecting AI Agents to ROS Controllers

## Purpose
This chapter explores the integration of AI agents with ROS 2 controllers, bridging the gap between high-level AI decision-making and low-level robot control. It covers the design patterns and implementation strategies for connecting intelligent systems to robotic control frameworks.

## Learning Outcomes
After completing this chapter, you will be able to:
- Design interfaces between AI agents and ROS 2 controllers
- Implement AI decision-making nodes that interact with robot controllers
- Create feedback loops between AI agents and robot sensors
- Integrate AI planning with ROS 2 action servers
- Implement safety mechanisms for AI-driven robot control
- Evaluate the performance of AI-ROS integration systems

## Prerequisites
- Understanding of ROS 2 concepts and node communication
- Knowledge of basic AI/ML concepts
- Completed previous chapters on ROS 2 and URDF
- Working knowledge of Python programming
- Understanding of robot control concepts

## Inputs
- Working ROS 2 installation (Humble Hawksbill or later)
- Understanding of AI/ML concepts
- Completed humanoid robot URDF model
- Knowledge of robot control systems
- Python programming skills

## Outputs
- AI agent that can command a simulated robot
- Integration between AI decision-making and ROS 2 controllers
- Working example of AI-ROS communication
- Safety mechanisms for AI-driven control

## Key Concepts
- **AI-ROS Integration**: Connecting artificial intelligence systems with robot control frameworks
- **Action Servers**: Long-running tasks with feedback and goal management in ROS 2
- **Behavior Trees**: Hierarchical task planning for complex robot behaviors
- **State Machines**: Managing robot states and transitions in AI systems
- **Feedback Control**: Closing the loop between AI decisions and robot execution
- **Safety Boundaries**: Ensuring AI decisions don't compromise robot safety
- **Simulation Integration**: Testing AI-ROS integration in simulated environments

## Chapter Outline
This chapter covers the integration of AI with robot control systems:

### 1. AI-ROS Communication Patterns
- Publisher-subscriber for sensor data
- Service calls for discrete actions
- Action servers for complex tasks

### 2. AI Agent Design for Robotics
- Perception-processing-action cycles
- State representation for robots
- Decision-making under uncertainty

### 3. Controller Integration
- Joint trajectory controllers
- Cartesian position controllers
- Force/torque control interfaces

### 4. Safety and Validation
- Safety constraints for AI decisions
- Validation of AI-generated commands
- Emergency stop mechanisms

## Hands-On Lab
### Creating an AI Control Agent

1. Navigate to your ROS 2 workspace and create the ai_control_agent package:
```bash
cd ~/robotics_ws/src
ros2 pkg create --build-type ament_python ai_control_agent
```

2. Create the AI control agent node in `ai_control_agent/ai_control_agent/simple_ai_agent.py`:
```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from sensor_msgs.msg import JointState
from control_msgs.msg import JointTrajectoryControllerState
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from builtin_interfaces.msg import Duration
import random
import math


class SimpleAIAgentNode(Node):
    def __init__(self):
        super().__init__('simple_ai_agent')

        # Publisher for joint trajectory commands
        self.joint_cmd_publisher = self.create_publisher(
            JointTrajectory,
            '/joint_trajectory_controller/joint_trajectory',
            10
        )

        # Subscriber for joint states
        self.joint_state_subscriber = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10
        )

        # Subscriber for obstacle alerts
        self.obstacle_subscriber = self.create_subscription(
            String,
            'obstacle_alert',
            self.obstacle_callback,
            10
        )

        # Timer for AI decision making
        timer_period = 2.0  # seconds
        self.timer = self.create_timer(timer_period, self.ai_decision_callback)

        # Robot state tracking
        self.current_joint_positions = {}
        self.obstacle_detected = False

        # Define joint names for the simple humanoid (from URDF)
        self.joint_names = [
            'left_shoulder', 'left_elbow', 'right_shoulder', 'right_elbow',
            'left_hip', 'left_knee', 'right_hip', 'right_knee'
        ]

        self.get_logger().info('Simple AI Agent Node initialized')

    def joint_state_callback(self, msg):
        """Update current joint positions from joint state messages"""
        for i, name in enumerate(msg.name):
            if name in self.joint_names:
                self.current_joint_positions[name] = msg.position[i]

    def obstacle_callback(self, msg):
        """Handle obstacle detection messages"""
        self.obstacle_detected = True
        self.get_logger().warn(f'Obstacle detected: {msg.data}')

        # Implement obstacle avoidance behavior
        self.execute_avoidance_behavior()

    def ai_decision_callback(self):
        """Main AI decision-making loop"""
        if self.obstacle_detected:
            self.get_logger().info('Avoiding obstacle')
            return

        # Simple AI behavior: move joints to random positions
        self.execute_random_movement()

    def execute_random_movement(self):
        """Execute random joint movements"""
        trajectory_msg = JointTrajectory()
        trajectory_msg.joint_names = self.joint_names

        point = JointTrajectoryPoint()

        # Generate random positions for each joint within limits
        for joint_name in self.joint_names:
            # Generate random position between -1.0 and 1.0 radians
            random_position = random.uniform(-1.0, 1.0)
            point.positions.append(random_position)

            # Set velocity and acceleration to 0 for simplicity
            point.velocities.append(0.0)
            point.accelerations.append(0.0)

        # Set the time from start (2 seconds)
        point.time_from_start = Duration(sec=2, nanosec=0)
        trajectory_msg.points = [point]

        self.joint_cmd_publisher.publish(trajectory_msg)
        self.get_logger().info(f'AI commanded joint positions: {[round(p, 2) for p in point.positions]}')

    def execute_avoidance_behavior(self):
        """Execute obstacle avoidance behavior"""
        trajectory_msg = JointTrajectory()
        trajectory_msg.joint_names = self.joint_names

        point = JointTrajectoryPoint()

        # For obstacle avoidance, move to a "safe" position
        # In a real implementation, this would be more sophisticated
        for joint_name in self.joint_names:
            # Move to neutral position (0.0) for all joints
            point.positions.append(0.0)
            point.velocities.append(0.0)
            point.accelerations.append(0.0)

        # Set the time from start (1 second for quick response)
        point.time_from_start = Duration(sec=1, nanosec=0)
        trajectory_msg.points = [point]

        self.joint_cmd_publisher.publish(trajectory_msg)
        self.get_logger().info('AI executed obstacle avoidance behavior')

        # Reset obstacle flag after a short delay
        self.create_timer(1.0, self.reset_obstacle_flag)

    def reset_obstacle_flag(self):
        """Reset the obstacle detection flag"""
        self.obstacle_detected = False
        self.get_logger().info('Obstacle flag reset')


def main(args=None):
    rclpy.init(args=args)
    node = SimpleAIAgentNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

3. Update the `setup.py` file in `ai_control_agent/setup.py`:
```python
import os
from glob import glob
from setuptools import setup
from setuptools import find_packages

package_name = 'ai_control_agent'

setup(
    name=package_name,
    version='0.0.0',
    packages=find_packages(exclude=['test']),
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Humanoid Robotics Book',
    maintainer_email='humanoid-robotics-book@example.com',
    description='AI control agent for the Physical AI & Humanoid Robotics book',
    license='Apache License 2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'simple_ai_agent = ai_control_agent.simple_ai_agent:main',
        ],
    },
)
```

4. Create the package.xml file in `ai_control_agent/package.xml`:
```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>ai_control_agent</name>
  <version>0.0.0</version>
  <description>AI control agent for the Physical AI & Humanoid Robotics book</description>
  <maintainer email="humanoid-robotics-book@example.com">Humanoid Robotics Book</maintainer>
  <license>Apache-2.0</license>

  <depend>rclpy</depend>
  <depend>std_msgs</depend>
  <depend>sensor_msgs</depend>
  <depend>control_msgs</depend>
  <depend>trajectory_msgs</depend>
  <depend>builtin_interfaces</depend>

  <exec_depend>python3-numpy</exec_depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

5. Create a launch file to integrate the AI agent with ros2_control:
```bash
mkdir -p ~/robotics_ws/src/ai_control_agent/launch
```

6. Create the launch file at `ai_control_agent/launch/ai_agent_control.launch.py`:
```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, RegisterEventHandler
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node
from launch.substitutions import Command, PathJoinSubstitution
from launch_ros.substitutions import FindPackageShare
from ament_index_python.packages import get_package_share_directory
from launch.event_handlers import OnProcessExit
import os


def generate_launch_description():
    # Get the package share directory
    pkg_share = get_package_share_directory('humanoid_description')

    # Define the URDF file path
    default_model_path = os.path.join(pkg_share, 'urdf/simple_humanoid.urdf')

    # Declare launch arguments
    model_arg = DeclareLaunchArgument(
        name='model',
        default_value=default_model_path,
        description='Absolute path to robot urdf file'
    )

    # Robot State Publisher node
    robot_state_publisher_node = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{
            'robot_description': Command(['xacro ', LaunchConfiguration('model')])
        }]
    )

    # ros2_control Node
    ros2_controllers_path = os.path.join(
        get_package_share_directory('ai_control_agent'),
        'config',
        'controllers.yaml'
    )

    # Create controllers.yaml configuration file
    controllers_config = """
    controller_manager:
      ros__parameters:
        update_rate: 100  # Hz

        joint_state_broadcaster:
          type: joint_state_broadcaster/JointStateBroadcaster

        joint_trajectory_controller:
          type: joint_trajectory_controller/JointTrajectoryController
    """

    # Write controllers.yaml to the config directory
    config_dir = os.path.join(get_package_share_directory('ai_control_agent'), 'config')
    os.makedirs(config_dir, exist_ok=True)
    controllers_file = os.path.join(config_dir, 'controllers.yaml')
    with open(controllers_file, 'w') as f:
        f.write(controllers_config)

    controller_manager_node = Node(
        package='controller_manager',
        executable='ros2_control_node',
        parameters=[controllers_file],
        remappings=[
            ('~/robot_description', '/robot_description'),
        ],
        output='both',
    )

    # Joint State Broadcaster
    joint_state_broadcaster_spawner = Node(
        package='controller_manager',
        executable='spawner',
        arguments=['joint_state_broadcaster'],
    )

    # Joint Trajectory Controller
    joint_trajectory_controller_spawner = Node(
        package='controller_manager',
        executable='spawner',
        arguments=['joint_trajectory_controller'],
    )

    # Simple AI Agent node
    ai_agent_node = Node(
        package='ai_control_agent',
        executable='simple_ai_agent',
        name='simple_ai_agent',
        output='screen'
    )

    # RViz2 node
    rviz_config_file = PathJoinSubstitution(
        [FindPackageShare('humanoid_description'), 'rviz', 'display.rviz']
    )

    rviz_node = Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        # arguments=['-d', rviz_config_file],
        output='screen'
    )

    # Delay rviz start after joint_state_broadcaster spawner finishes
    delay_rviz_after_joint_state_broadcaster_spawner = RegisterEventHandler(
        event_handler=OnProcessExit(
            target_action=joint_state_broadcaster_spawner,
            on_exit=[rviz_node],
        )
    )

    return LaunchDescription([
        model_arg,
        robot_state_publisher_node,
        controller_manager_node,
        joint_state_broadcaster_spawner,
        joint_trajectory_controller_spawner,
        ai_agent_node,
        delay_rviz_after_joint_state_broadcaster_spawner
    ])
```

7. Build the package:
```bash
cd ~/robotics_ws
colcon build --packages-select ai_control_agent
source install/setup.bash
```

## Safety Notes
- Always implement safety limits and bounds checking in AI agents
- Include emergency stop mechanisms in all AI-driven control systems
- Test AI-ROS integration thoroughly in simulation before real robot deployment
- Implement proper error handling and recovery strategies
- Monitor AI agent behavior during execution and implement intervention mechanisms

## Evaluation Criteria
- Can the AI agent successfully command robot joints?
- Is there proper feedback from robot sensors to the AI agent?
- Are safety mechanisms properly implemented?
- Can the AI agent adapt its behavior based on sensor feedback?
- Is the integration between AI and ROS 2 controllers functional and reliable?