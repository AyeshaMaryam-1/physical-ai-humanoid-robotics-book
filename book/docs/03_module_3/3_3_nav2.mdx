---
sidebar_position: 3
title: "Navigation & Motion Planning (Nav2)"
---

# Navigation & Motion Planning (Nav2)

## Purpose
This chapter introduces the Navigation 2 (Nav2) stack for humanoid robots, focusing on autonomous navigation and motion planning in complex environments. We'll configure Nav2 for our humanoid robot, create maps of Isaac Sim environments, and implement autonomous navigation capabilities that enable the robot to navigate safely and efficiently to specified goal poses.

## Learning Outcomes
After completing this chapter, you will be able to:
- Configure the Nav2 stack for humanoid robot navigation
- Create maps of environments using simulated LiDAR data from Isaac Sim
- Implement localization, path planning, and motion control algorithms
- Set up navigation safety mechanisms and obstacle avoidance
- Integrate Nav2 with Isaac Sim for realistic navigation testing
- Evaluate navigation performance and tune parameters for optimal results

## Prerequisites
- Completed Module 1 (ROS 2 fundamentals and humanoid URDF)
- Completed Module 2 (Gazebo & Unity digital twin)
- Completed Module 3.1-3.2 (Isaac Sim and perception pipeline)
- Understanding of coordinate frames and transformations (TF)
- Experience with ROS 2 launch files and parameter configuration
- Basic knowledge of path planning algorithms

## Inputs
- Humanoid robot model with LiDAR sensor in Isaac Sim
- Working Isaac Sim environment with ROS 2 bridge
- Understanding of robot kinematics and dynamics
- Navigation concepts (localization, mapping, path planning)

## Outputs
- Nav2 configuration files for humanoid robot
- Map of Isaac Sim environment
- Autonomous navigation pipeline
- Navigation safety and recovery behaviors
- Performance evaluation metrics for navigation

## Key Concepts
- **Navigation 2 (Nav2) Stack**: ROS 2 navigation framework for autonomous navigation
- **Simultaneous Localization and Mapping (SLAM)**: Creating maps while localizing the robot
- **Path Planning**: Global and local path planning algorithms (A*, Dijkstra, DWA, etc.)
- **Motion Control**: Converting planned paths to robot commands
- **Safety and Recovery**: Navigation safety mechanisms and recovery behaviors
- **Environment Mapping**: Creating occupancy grid maps from sensor data
- **Coordinate Frames**: Managing TF trees for navigation components

## Chapter Outline
This chapter develops a complete Nav2 navigation system:

### 1. Nav2 Architecture and Components
- Understanding the Nav2 stack architecture
- Key components: Planner, Controller, BT Navigator, Recovery
- Configuration and parameter tuning

### 2. SLAM and Mapping
- Creating maps using simulated LiDAR data
- Configuring SLAM algorithms for humanoid robots
- Map quality assessment and optimization

### 3. Navigation Configuration
- Setting up Nav2 for humanoid robot kinematics
- Configuring global and local planners
- Tuning navigation parameters

### 4. Autonomous Navigation
- Implementing goal-based navigation
- Safety mechanisms and obstacle avoidance
- Performance evaluation and tuning

## Hands-On Lab

### Setting up Nav2 for Humanoid Robot Navigation

1. **Nav2 Package Structure:**
   Create a ROS 2 package for Nav2 configuration: `robotics_ws/src/humanoid_nav2_config/package.xml`

   ```xml
   <?xml version="1.0"?>
   <?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
   <package format="3">
     <name>humanoid_nav2_config</name>
     <version>0.0.0</version>
     <description>Nav2 configuration for humanoid robot in the Physical AI & Humanoid Robotics book</description>
     <maintainer email="humanoid-robotics-book@example.com">Humanoid Robotics Book</maintainer>
     <license>Apache-2.0</license>

     <depend>nav2_bringup</depend>
     <depend>nav2_map_server</depend>
     <depend>nav2_planner</depend>
     <depend>nav2_controller</depend>
     <depend>nav2_behavior_tree</depend>
     <depend>nav2_bt_navigator</depend>
     <depend>nav2_recovery</depend>
     <depend>nav2_lifecycle_manager</depend>
     <depend>nav2_util</depend>
     <depend>slam_toolbox</depend>

     <test_depend>ament_copyright</test_depend>
     <test_depend>ament_flake8</test_depend>
     <test_depend>ament_pep257</test_depend>
     <test_depend>python3-pytest</test_depend>

     <export>
       <build_type>ament_cmake</build_type>
     </export>
   </package>
   ```

2. **Setup File:**
   Create `robotics_ws/src/humanoid_nav2_config/CMakeLists.txt`:

   ```cmake
   cmake_minimum_required(VERSION 3.8)
   project(humanoid_nav2_config)

   if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
     add_compile_options(-Wall -Wextra -Wpedantic)
   endif()

   # Find dependencies
   find_package(ament_cmake REQUIRED)

   # Install configuration files
   install(
     DIRECTORY config launch maps
     DESTINATION share/${PROJECT_NAME}
   )

   if(BUILD_TESTING)
     find_package(ament_lint_auto REQUIRED)
     ament_lint_auto_find_test_dependencies()
   endif()

   ament_package()
   ```

3. **Navigation Configuration:**
   Create the main navigation configuration file: `robotics_ws/src/humanoid_nav2_config/config/nav2_params.yaml`

   ```yaml
   amcl:
     ros__parameters:
       use_sim_time: True
       alpha1: 0.2
       alpha2: 0.2
       alpha3: 0.2
       alpha4: 0.2
       alpha5: 0.2
       base_frame_id: "base_link"
       beam_skip_distance: 0.5
       beam_skip_error_threshold: 0.9
       beam_skip_threshold: 0.3
       do_beamskip: false
       global_frame_id: "map"
       lambda_short: 0.1
       laser_likelihood_max_dist: 2.0
       laser_max_range: 10.0
       laser_min_range: -1.0
       laser_model_type: "likelihood_field"
       max_beams: 60
       max_particles: 2000
       min_particles: 500
       odom_frame_id: "odom"
       pf_err: 0.05
       pf_z: 0.99
       recovery_alpha_fast: 0.0
       recovery_alpha_slow: 0.0
       resample_interval: 1
       robot_model_type: "nav2_amcl::DifferentialMotionModel"
       save_pose_rate: 0.5
       sigma_hit: 0.2
       tf_broadcast: true
       transform_tolerance: 1.0
       update_min_a: 0.2
       update_min_d: 0.25
       z_hit: 0.5
       z_max: 0.05
       z_rand: 0.5
       z_short: 0.05
       scan_topic: scan

   amcl_map_client:
     ros__parameters:
       use_sim_time: True

   amcl_rclcpp_node:
     ros__parameters:
       use_sim_time: True

   bt_navigator:
     ros__parameters:
       use_sim_time: True
       global_frame: map
       robot_base_frame: base_link
       odom_topic: /odom
       bt_loop_duration: 10
       default_server_timeout: 20
       enable_groot_monitoring: True
       groot_zmq_publisher_port: 1666
       groot_zmq_server_port: 1667
       navigate_through_poses: False
       navigate_to_pose_bt_xml: "navigate_to_pose_w_replanning_and_recovery.xml"
       navigate_through_poses_bt_xml: "navigate_through_poses_w_replanning_and_recovery.xml"
       plugin_lib_names:
       - nav2_compute_path_to_pose_action_bt_node
       - nav2_compute_path_through_poses_action_bt_node
       - nav2_follow_path_action_bt_node
       - nav2_back_up_action_bt_node
       - nav2_spin_action_bt_node
       - nav2_wait_action_bt_node
       - nav2_clear_costmap_service_bt_node
       - nav2_is_stuck_condition_bt_node
       - nav2_goal_reached_condition_bt_node
       - nav2_goal_updated_condition_bt_node
       - nav2_initial_pose_received_condition_bt_node
       - nav2_reinitialize_global_localization_service_bt_node
       - nav2_rate_controller_bt_node
       - nav2_distance_controller_bt_node
       - nav2_speed_controller_bt_node
       - nav2_truncate_path_action_bt_node
       - nav2_truncate_path_local_action_bt_node
       - nav2_goal_updater_node_bt_node
       - nav2_recovery_node_bt_node
       - nav2_pipeline_sequence_bt_node
       - nav2_round_robin_node_bt_node
       - nav2_transform_available_condition_bt_node
       - nav2_time_expired_condition_bt_node
       - nav2_path_expiring_timer_condition
       - nav2_distance_traveled_condition_bt_node
       - nav2_single_trigger_bt_node
       - nav2_is_battery_low_condition_bt_node
       - nav2_navigate_through_poses_action_bt_node
       - nav2_navigate_to_pose_action_bt_node
       - nav2_remove_passed_goals_action_bt_node
       - nav2_planner_selector_bt_node
       - nav2_controller_selector_bt_node
       - nav2_goal_checker_selector_bt_node
       - nav2_controller_cancel_bt_node
       - nav2_path_longer_on_approach_bt_node
       - nav2_wait_cancel_bt_node

   bt_navigator_rclcpp_node:
     ros__parameters:
       use_sim_time: True

   controller_server:
     ros__parameters:
       use_sim_time: True
       controller_frequency: 20.0
       min_x_velocity_threshold: 0.001
       min_y_velocity_threshold: 0.5
       min_theta_velocity_threshold: 0.001
       failure_tolerance: 0.3
       progress_checker_plugin: "progress_checker"
       goal_checker_plugin: "goal_checker"
       controller_plugins: ["FollowPath"]

       # Progress checker parameters
       progress_checker:
         plugin: "nav2_controller::SimpleProgressChecker"
         required_movement_radius: 0.5
         movement_time_allowance: 10.0

       # Goal checker parameters
       goal_checker:
         plugin: "nav2_controller::SimpleGoalChecker"
         xy_goal_tolerance: 0.25
         yaw_goal_tolerance: 0.25
         stateful: True

       # Controller parameters
       FollowPath:
         plugin: "nav2_rotation_shim_controller::RotationShimController"
         # Parameters for the underlying local planner
         progress_checker:
           plugin: "nav2_controller::SimpleProgressChecker"
           required_movement_radius: 0.5
           movement_time_allowance: 10.0
         goal_checker:
           plugin: "nav2_controller::SimpleGoalChecker"
           xy_goal_tolerance: 0.25
           yaw_goal_tolerance: 0.25
           stateful: True
         local_planner:
           plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"
           desired_linear_vel: 0.5
           max_linear_accel: 2.5
           max_linear_decel: 2.5
           desired_angular_vel: 1.0
           max_angular_accel: 3.2
           min_angular_vel: 0.0
           max_robot_pose_age: 1.0
           transform_tolerance: 0.1
           min_approach_linear_velocity: 0.05
           angular_dist_threshold: 0.785
           forward_sampling_distance: 0.5
           rotate_to_heading_angular_vel: 1.8
           max_angular_vel: 1.5
           min_linear_velocity: 0.0
           max_linear_velocity: 0.5
           use_velocity_scaled_path: false
           min_curvature_radius: 0.1
           lookahead_time: 1.5
           use_interpolation: true

   controller_server_rclcpp_node:
     ros__parameters:
       use_sim_time: True

   local_costmap:
     local_costmap:
       ros__parameters:
         update_frequency: 5.0
         publish_frequency: 2.0
         global_frame: odom
         robot_base_frame: base_link
         use_sim_time: True
         rolling_window: true
         width: 10
         height: 10
         resolution: 0.05
         robot_radius: 0.3
         plugins: ["voxel_layer", "inflation_layer"]
         inflation_layer:
           plugin: "nav2_costmap_2d::InflationLayer"
           cost_scaling_factor: 3.0
           inflation_radius: 0.55
         voxel_layer:
           plugin: "nav2_costmap_2d::VoxelLayer"
           enabled: True
           publish_voxel_map: True
           origin_z: 0.0
           z_resolution: 0.05
           z_voxels: 16
           max_obstacle_height: 2.0
           mark_threshold: 0
           observation_sources: scan
           scan:
             topic: /scan
             max_obstacle_height: 2.0
             clearing: True
             marking: True
             data_type: "LaserScan"
             raytrace_max_range: 10.0
             raytrace_min_range: 0.0
             obstacle_max_range: 10.0
             obstacle_min_range: 0.0
         always_send_full_costmap: True
     local_costmap_client:
       ros__parameters:
         use_sim_time: True
     local_costmap_rclcpp_node:
       ros__parameters:
         use_sim_time: True

   global_costmap:
     global_costmap:
       ros__parameters:
         update_frequency: 1.0
         publish_frequency: 1.0
         global_frame: map
         robot_base_frame: base_link
         use_sim_time: True
         robot_radius: 0.3
         resolution: 0.05
         track_unknown_space: true
         plugins: ["static_layer", "obstacle_layer", "inflation_layer"]
         obstacle_layer:
           plugin: "nav2_costmap_2d::ObstacleLayer"
           enabled: True
           observation_sources: scan
           scan:
             topic: /scan
             max_obstacle_height: 2.0
             clearing: True
             marking: True
             data_type: "LaserScan"
             raytrace_max_range: 10.0
             raytrace_min_range: 0.0
             obstacle_max_range: 10.0
             obstacle_min_range: 0.0
         static_layer:
           plugin: "nav2_costmap_2d::StaticLayer"
           map_subscribe_transient_local: True
         inflation_layer:
           plugin: "nav2_costmap_2d::InflationLayer"
           cost_scaling_factor: 3.0
           inflation_radius: 0.55
         always_send_full_costmap: True
     global_costmap_client:
       ros__parameters:
         use_sim_time: True
     global_costmap_rclcpp_node:
       ros__parameters:
         use_sim_time: True

   map_server:
     ros__parameters:
       use_sim_time: True
       yaml_filename: "turtlebot3_world.yaml"

   map_saver:
     ros__parameters:
       use_sim_time: True
       save_map_timeout: 5.0
       free_thresh_default: 0.25
       occupied_thresh_default: 0.65

   planner_server:
     ros__parameters:
       expected_planner_frequency: 20.0
       use_sim_time: True
       planner_plugins: ["GridBased"]
       GridBased:
         plugin: "nav2_navfn_planner::NavfnPlanner"
         tolerance: 0.5
         use_astar: false
         allow_unknown: true

   planner_server_rclcpp_node:
     ros__parameters:
       use_sim_time: True

   recovery_server:
     ros__parameters:
       use_sim_time: True
       recovery_plugins: ["spin", "backup", "wait"]
       spin:
         plugin: "nav2_recoveries::Spin"
         sim_frequency: 20
         angle_thresh: 0.0
         time_allowance: 20
       backup:
         plugin: "nav2_recoveries::BackUp"
         sim_frequency: 20
         backup_dist: -0.15
         backup_speed: 0.025
       wait:
         plugin: "nav2_recoveries::Wait"
         sim_frequency: 20
         wait_duration: 5

   recovery_server_rclcpp_node:
     ros__parameters:
       use_sim_time: True

   robot_state_publisher:
     ros__parameters:
       use_sim_time: True

   waypoint_follower:
     ros__parameters:
       use_sim_time: True
       loop_rate: 20
       stop_on_failure: false
       waypoint_task_executor_plugin: "wait_at_waypoint"
       wait_at_waypoint:
         plugin: "nav2_waypoint_follower::WaitAtWaypoint"
         enabled: True
         wait_time: 200
   ```

4. **SLAM Configuration:**
   Create a SLAM configuration file for mapping: `robotics_ws/src/humanoid_nav2_config/config/slam_params.yaml`

   ```yaml
   slam_toolbox:
     ros__parameters:
       # Plugin params
       solver_plugin: solver_plugins::CeresSolver
       ceres_linear_solver: SPARSE_NORMAL_CHOLESKY
       ceres_preconditioner: SCHUR_JACOBI
       ceres_trust_strategy: LEVENBERG_MARQUARDT
       ceres_dogleg_type: TRADITIONAL_DOGLEG
       ceres_loss_function: None

       # ROS Parameters
       odom_frame: odom
       map_frame: map
       base_frame: base_link
       scan_topic: /scan
       mode: mapping #localization

       # Additional parameters
       debug_logging: false
       throttle_scans: 1
       transform_publish_period: 0.02 #0.02
       map_update_interval: 2.0
       resolution: 0.05
       max_laser_range: 20.0 #for scan matching
       minimum_time_interval: 0.5
       transform_timeout: 0.2
       tf_buffer_duration: 30.
       stack_size_to_use: 40000000 #// program needs a larger stack size to prevent crashing
       enable_interactive_mode: true

       # General Parameters
       use_scan_matching: true
       use_scan_barycenter: true
       minimum_travel_distance: 0.5
       minimum_travel_heading: 0.5
       scan_buffer_size: 10
       scan_buffer_maximum_scan_distance: 10.0
       link_match_minimum_response_fine: 0.1
       link_scan_maximum_distance: 1.5
       loop_search_maximum_distance: 3.0
       do_loop_closing: true
       loop_match_minimum_chain_size: 10
       loop_match_maximum_variance_coarse: 3.0
       loop_match_minimum_response_coarse: 0.35
       loop_match_minimum_response_fine: 0.45

       # Correlation Parameters - Correlation Parameters
       correlation_search_space_dimension: 0.5
       correlation_search_space_resolution: 0.01
       correlation_search_space_smear_deviation: 0.1

       # Correlation Parameters - Loop Closure Parameters
       loop_search_space_dimension: 8.0
       loop_search_space_resolution: 0.05
       loop_search_space_smear_deviation: 0.03

       # Scan Matcher Parameters
       distance_variance_penalty: 0.5
       angle_variance_penalty: 1.0

       fine_search_angle_offset: 0.00349
       coarse_search_angle_offset: 0.349
       coarse_angle_resolution: 0.0349
       minimum_angle_penalty: 0.9
       minimum_distance_penalty: 0.5
       use_icp: false
       icp_iterations: 1000
       icp_epsilon: 0.001
       icp_threshold: 1.0
       icp_sigma: 0.05
       icp_success_ratio: 0.05
       convergence_epsilon_a: 0.001
       convergence_epsilon_x: 0.001
       convergence_epsilon_theta: 0.001
       max_iterations: 1000
   ```

5. **Navigation Launch File:**
   Create a launch file for Nav2 navigation: `robotics_ws/src/humanoid_nav2_config/launch/navigation_launch.py`

   ```python
   import os
   from launch import LaunchDescription
   from launch.actions import DeclareLaunchArgument, SetEnvironmentVariable
   from launch.substitutions import LaunchConfiguration
   from launch_ros.actions import Node
   from ament_index_python.packages import get_package_share_directory
   from nav2_common.launch import RewrittenYaml


   def generate_launch_description():
       # Get the package share directory
       pkg_share = get_package_share_directory('humanoid_nav2_config')

       # Declare launch arguments
       use_sim_time = DeclareLaunchArgument(
           'use_sim_time',
           default_value='true',
           description='Use simulation (Isaac Sim) clock if true'
       )

       params_file = DeclareLaunchArgument(
           'params_file',
           default_value=os.path.join(pkg_share, 'config', 'nav2_params.yaml'),
           description='Full path to the ROS2 parameters file to use for all launched nodes'
       )

       # Create lifecycle manager node
       lifecycle_manager = Node(
           package='nav2_lifecycle_manager',
           executable='lifecycle_manager',
           name='lifecycle_manager',
           output='screen',
           parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')},
                       {'autostart': True},
                       {'node_names': ['map_server',
                                      'planner_server',
                                      'controller_server',
                                      'bt_navigator',
                                      'amcl',
                                      'local_costmap',
                                      'global_costmap']}]
       )

       # Map server
       map_server = Node(
           package='nav2_map_server',
           executable='map_server',
           name='map_server',
           parameters=[{'yaml_filename': os.path.join(pkg_share, 'maps', 'isaac_sim_map.yaml')},
                       {'frame_id': 'map'},
                       {'use_sim_time': LaunchConfiguration('use_sim_time')},
                       {'topic_name': '/map'},
                       {'broadcast_2tf': True}],
           output='screen'
       )

       # Planner server
       planner_server = Node(
           package='nav2_planner',
           executable='planner_server',
           name='planner_server',
           parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],
           output='screen'
       )

       # Controller server
       controller_server = Node(
           package='nav2_controller',
           executable='controller_server',
           name='controller_server',
           parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],
           output='screen'
       )

       # Behavior tree navigator
       bt_navigator = Node(
           package='nav2_bt_navigator',
           executable='bt_navigator',
           name='bt_navigator',
           parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],
           output='screen'
       )

       # Local costmap server
       local_costmap = Node(
           package='nav2_costmap_2d',
           executable='nav2_costmap_2d',
           name='local_costmap',
           parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],
           output='screen'
       )

       # Global costmap server
       global_costmap = Node(
           package='nav2_costmap_2d',
           executable='nav2_costmap_2d',
           name='global_costmap',
           parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],
           output='screen'
       )

       # AMCL (for localization)
       amcl = Node(
           package='nav2_amcl',
           executable='amcl',
           name='amcl',
           parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],
           output='screen'
       )

       # Velocity smoother
       velocity_smoother = Node(
           package='nav2_velocity_smoother',
           executable='velocity_smoother',
           name='velocity_smoother',
           parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],
           output='screen'
       )

       # Pose publisher
       pose_publisher = Node(
           package='nav2_pose_smoother',
           executable='smoother_node',
           name='pose_publisher',
           parameters=[LaunchConfiguration('params_file'), {'use_sim_time': LaunchConfiguration('use_sim_time')}],
           output='screen'
       )

       return LaunchDescription([
           use_sim_time,
           params_file,
           lifecycle_manager,
           map_server,
           planner_server,
           controller_server,
           bt_navigator,
           local_costmap,
           global_costmap,
           amcl,
           velocity_smoother,
           pose_publisher
       ])
   ```

6. **SLAM Launch File:**
   Create a launch file for SLAM mapping: `robotics_ws/src/humanoid_nav2_config/launch/slam_launch.py`

   ```python
   import os
   from launch import LaunchDescription
   from launch.actions import DeclareLaunchArgument
   from launch.substitutions import LaunchConfiguration
   from launch_ros.actions import Node
   from ament_index_python.packages import get_package_share_directory


   def generate_launch_description():
       # Get the package share directory
       pkg_share = get_package_share_directory('humanoid_nav2_config')

       # Declare launch arguments
       use_sim_time = DeclareLaunchArgument(
           'use_sim_time',
           default_value='true',
           description='Use simulation (Isaac Sim) clock if true'
       )

       params_file = DeclareLaunchArgument(
           'params_file',
           default_value=os.path.join(pkg_share, 'config', 'slam_params.yaml'),
           description='Full path to the ROS2 parameters file to use for all launched nodes'
       )

       # SLAM Toolbox node
       slam_toolbox = Node(
           parameters=[
               LaunchConfiguration('params_file'),
               {'use_sim_time': LaunchConfiguration('use_sim_time')}
           ],
           package='slam_toolbox',
           executable='async_slam_toolbox_node',
           name='slam_toolbox',
           output='screen'
       )

       return LaunchDescription([
           use_sim_time,
           params_file,
           slam_toolbox
       ])
   ```

7. **Isaac Sim Navigation Scene:**
   Create an Isaac Sim scene for navigation testing: `isaac_sim_assets/isaac_sim_project/scenes/navigation_test.usd`

   ```usda
   #usda 1.0
   (
       doc = "Navigation test scene for Isaac Sim"
       metersPerUnit = 1.0
       upAxis = "Y"
   )

   def Xform "World"
   {
       def PhysicsScene "physicsScene"
       {
           float3 gravity = (0, 0, -981)
           float timeStepsPerSecond = 60
           float maxSubSteps = 1
       }

       def Xform "ground_plane"
       {
           def Plane "plane"
           {
               add xformOp:scale = (20, 20, 1)
               add xformOp:translate = (0, 0, 0)
               prepend apiSchemas = ["PhysicsCollisionAPI"]
           }
       }

       # Add some obstacles for navigation challenge
       def Xform "obstacles"
       {
           def Cube "wall_1"
           {
               add xformOp:scale = (10, 0.2, 2)
               add xformOp:translate = (0, 5, 1)
               prepend apiSchemas = ["PhysicsRigidBodyAPI"]
           }

           def Cube "wall_2"
           {
               add xformOp:scale = (0.2, 10, 2)
               add xformOp:translate = (5, 0, 1)
               prepend apiSchemas = ["PhysicsRigidBodyAPI"]
           }

           def Cube "obstacle_1"
           {
               add xformOp:scale = (1, 1, 1)
               add xformOp:translate = (2, 2, 0.5)
               prepend apiSchemas = ["PhysicsRigidBodyAPI"]
           }

           def Cube "obstacle_2"
           {
               add xformOp:scale = (1.5, 0.5, 1)
               add xformOp:translate = (-3, -2, 0.5)
               prepend apiSchemas = ["PhysicsRigidBodyAPI"]
           }
       }

       def Xform "humanoid_robot"
       {
           add references = </humanoid_robot/humanoid_with_sensors.usda>
           add xformOp:translate = (-5, -5, 1.0)

           # Ensure the LiDAR is properly configured for navigation
           def "RotatingLidar"
           {
               add xformOp:translate = (0, 0.5, 0.2)
               add xformOp:rotateXYZ = (0, 0, 0)
           }
       }

       def Xform "distantLight"
       {
           add xformOp:rotateXYZ = (0, 45, 0)
           def DistantLight "distantLight"
           {
               float intensity = 300
               color color = (1, 1, 1)
           }
       }

       def Xform "domeLight"
       {
           def DomeLight "domeLight"
           {
               float intensity = 1
               color color = (0.2, 0.2, 0.2)
           }
       }
   }
   ```

8. **Navigation Test Script:**
   Create a script to send navigation goals: `robotics_ws/src/humanoid_nav2_config/scripts/send_navigation_goal.py`

   ```python
   #!/usr/bin/env python3

   """
   Navigation Goal Sender

   This script sends navigation goals to the Nav2 stack for the humanoid robot.
   """

   import rclpy
   from rclpy.node import Node
   from rclpy.action import ActionClient
   from nav2_msgs.action import NavigateToPose
   from geometry_msgs.msg import PoseStamped
   from builtin_interfaces.msg import Duration
   import time


   class NavigationGoalSender(Node):
       def __init__(self):
           super().__init__('navigation_goal_sender')

           # Create action client for navigation
           self.nav_to_pose_client = ActionClient(
               self,
               NavigateToPose,
               'navigate_to_pose'
           )

           # Wait for the action server to be available
           self.nav_to_pose_client.wait_for_server()

           self.get_logger().info("Navigation goal sender initialized")

       def send_goal(self, x, y, theta):
           """Send a navigation goal to the specified pose"""
           goal_msg = NavigateToPose.Goal()

           # Set the goal pose
           goal_msg.pose.header.frame_id = 'map'
           goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
           goal_msg.pose.pose.position.x = x
           goal_msg.pose.pose.position.y = y
           goal_msg.pose.pose.position.z = 0.0

           # Convert theta (yaw) to quaternion
           import math
           from tf_transformations import quaternion_from_euler
           quat = quaternion_from_euler(0, 0, theta)
           goal_msg.pose.pose.orientation.x = quat[0]
           goal_msg.pose.pose.orientation.y = quat[1]
           goal_msg.pose.pose.orientation.z = quat[2]
           goal_msg.pose.pose.orientation.w = quat[3]

           # Send the goal
           self.get_logger().info(f"Sending navigation goal to ({x}, {y}, {theta})")
           future = self.nav_to_pose_client.send_goal_async(goal_msg)
           future.add_done_callback(self.goal_response_callback)

       def goal_response_callback(self, future):
           """Handle the goal response"""
           goal_handle = future.result()
           if not goal_handle.accepted:
               self.get_logger().info('Goal rejected')
               return

           self.get_logger().info('Goal accepted')
           result_future = goal_handle.get_result_async()
           result_future.add_done_callback(self.get_result_callback)

       def get_result_callback(self, future):
           """Handle the result of the navigation"""
           result = future.result().result
           self.get_logger().info(f'Navigation result: {result}')
           rclpy.shutdown()


   def main(args=None):
       rclpy.init(args=args)

       # Create the navigation goal sender
       nav_sender = NavigationGoalSender()

       # Send a navigation goal (example: go to x=5, y=5, theta=0)
       nav_sender.send_goal(5.0, 5.0, 0.0)

       # Spin to process callbacks
       rclpy.spin(nav_sender)


   if __name__ == '__main__':
       main()
   ```

9. **Testing the Navigation System:**
   - Launch Isaac Sim with the navigation test scene
   - Start the SLAM system to create a map:
   ```bash
   ros2 launch humanoid_nav2_config slam_launch.py
   ```
   - Drive the robot around to map the environment
   - Save the map:
   ```bash
   ros2 run nav2_map_server map_saver_cli -f ~/map
   ```
   - Launch the navigation system with the saved map:
   ```bash
   ros2 launch humanoid_nav2_config navigation_launch.py
   ```
   - Send navigation goals using the test script or RViz2

## Safety Notes
- Implement proper safety limits for navigation speeds and accelerations
- Ensure navigation recovery behaviors are properly configured
- Test navigation in simulation before attempting on physical robots
- Validate localization accuracy before autonomous navigation
- Implement proper obstacle detection and avoidance mechanisms

## Evaluation Criteria
- Can the humanoid robot create accurate maps of the Isaac Sim environment?
- Does the navigation system plan valid paths around obstacles?
- Can the robot successfully navigate to specified goal poses?
- Are safety mechanisms properly implemented to avoid collisions?
- Does the navigation system recover from failures appropriately?
- Can the robot maintain stable navigation performance in complex environments?